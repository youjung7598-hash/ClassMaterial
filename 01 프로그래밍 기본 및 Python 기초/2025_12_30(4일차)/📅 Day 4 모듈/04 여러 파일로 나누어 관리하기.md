# 여러 파일로 코드 나누기(모듈 분리)

### 🔹 왜 여러 파일로 나누어야 할까?

한 파일에 모든 코드를 넣으면 처음에는 편하지만, 기능이 조금만 늘어나도 다음 일이 생깁니다.

- 파일 길이가 300~500줄이 넘어가면
    → **찾기 힘들고, 수정 시 실수**가 많아짐
    
- 여러 사람이 동시에 작업하기 힘듦
    → 항상 같은 파일에서 충돌(conflict)
    
- 기능이 섞여 있어서
    → “이 함수가 어디서 쓰이는지” 파악이 어려움
    

그래서 실무에서는 다음 원칙을 기본으로 가져갑니다.

> ✅ “역할(기능)별로 파일을 나누고, 파일별로 책임을 분리한다”
> ✅ **한 파일 = 한 역할(책임)**
> ✅ **변경 이유가 같은 코드끼리 묶고, 변경 이유가 다른 코드는 분리한다**

---

### 🔹 파일을 나눌 때의 기본 기준 (초보자용)

처음에는 아래 3가지만 기억하게 하면 충분합니다.

1. **입력/출력(IO)** 관련 코드
    - `print()`, `input()`, 파일 읽고 쓰기, API 호출 등
2. **순수 로직(계산/비즈니스 로직)**
    - 합계 계산, 통계, 필터링, 정렬, 유효성 검사 등
3. **프로그램 시작점(실행 흐름)**
    - “먼저 뭐 하고, 그 다음 뭐 한다”를 적어두는 `main.py` 같은 파일

→ “입출력 + 로직 + 시작점”을 **서로 다른 파일로 분리**하는 감각을 잡는 것이 목표입니다.

---

### 🔹 예제 1: 한 파일짜리 프로그램 → 여러 파일로 나누기

### 1) 나누기 전: `app_before.py` (학생 평균 점수 계산)

`[문제점 요약]`

- 한 파일 안에 데이터 저장, 계산 로직, 입출력(입력/출력), 실행 흐름이 모두 섞여 있음
- 코드 길이가 길어지고, 기능이 늘어나면 유지보수가 어려워짐
- 여러 사람이 함께 작업하기에도 불편 (항상 동일 파일을 수정해야 함)

→ **4일차 목표:** 이 코드에서 역할별로 부분을 나눠서

`models.py / services.py / io_utils.py / main.py` 같은 구조로 분리하는 연습을 한다.
```python
# app_before.py

# --------------------------------------------
# [1] 전역 데이터 영역 (상태 저장)
# - 프로그램 전체에서 사용하는 데이터(students)를 한 곳에 두고 있음
# - 규모가 커지면 이 부분은 보통 'models.py' 또는 'repository.py'처럼
#   데이터 구조/저장을 담당하는 파일로 분리하게 됨
# --------------------------------------------
students = []

# --------------------------------------------
# [2] 로직(비즈니스 로직) 함수 영역
# - 입력 받은 점수로 평균을 계산하고, 학생 정보를 저장하는 기능
# - 화면에 성적표를 출력하는 기능
# - "무엇을 출력할지 / 어떻게 계산할지"에 대한 순수 로직이 들어있음
# - 나중에는 이 부분을 따로 떼어서 'services.py' 같은 파일로 분리하는 것이 좋음
#   → 이유: 로직은 입출력(프린트, input)과 분리해야 테스트와 재사용이 쉬움
# --------------------------------------------
def add_student(name, scores):
    # 평균 계산 로직 (계산/비즈니스 로직)
    avg = sum(scores) / len(scores)
    # 전역 리스트에 데이터 추가 (데이터 저장 로직)
    students.append({"name": name, "scores": scores, "avg": avg})

def print_report():
    # 출력(프레젠테이션) 로직
    # 이 함수는 화면에 어떻게 보여줄지에 대한 책임을 가지고 있음
    print("=== 성적표 ===")
    for s in students:
        print(f"{s['name']}: 평균 {s['avg']:.1f}점")

# --------------------------------------------
# [3] 프로그램 전체 흐름 제어(main 함수)
# - 사용자 입력을 반복해서 받는 부분 (입력 I/O)
# - 입력 받은 값을 이용해 앞에서 정의한 로직(add_student, print_report)을 호출
# - "프로그램이 어떻게 진행되는지"를 스토리처럼 적어두는 곳
# - 실무에서는 이런 '흐름 제어' 코드만 모아놓은 main.py(또는 views.py 등)를 따로 둠
#   → 이유: 흐름을 한눈에 보기 쉬워지고, 세부 기능은 다른 파일로 위임할 수 있음
# --------------------------------------------
def main():
    # [입력 루프] : 사용자로부터 이름과 점수를 반복 입력받는 역할
    while True:
        name = input("이름 (종료:q): ")     # <-- 입력 I/O
        if name == "q":
            break

        # 이 부분도 나중에는 별도 함수로 분리 가능 (예: input_scores(subjects))
        scores = []
        for subject in ["국어", "영어", "수학"]:
            score = int(input(f"{subject} 점수: "))  # <-- 입력 I/O
            scores.append(score)

        # 비즈니스 로직 호출 (학생 데이터 추가)
        add_student(name, scores)

    # 모든 입력이 끝난 후 결과 출력
    print_report()   # <-- 출력 I/O

# --------------------------------------------
# [4] 실행 시작점
# - 이 파일을 "직접 실행했을 때만" main()을 실행하도록 하는 관용구
# - 나중에 이 파일이 다른 모듈에서 import 되더라도,
#   main()이 자동으로 실행되지 않도록 막아주는 역할
# - 파일 분리 후에도 이 구조는 그대로 유지하는 것이 좋음
# --------------------------------------------
if __name__ == "__main__":
    main()
```

---

### 🔹 “한 파일에 다 넣으면” 실제로 어떤 문제가 생기나?

- “점수 입력”을 고치려다가 “출력”이 깨짐
- “출력 형식”만 바꾸고 싶은데 계산 로직까지 건드리게 됨
- 팀으로 작업하면 같은 파일을 계속 수정해서 충돌(conflict)이 남

그래서 실무에서는 이런 원칙을 씁니다.

> ✅ 한 파일 = 한 역할(책임)
> ✅ **변경 이유가 같은 코드끼리 묶고, 변경 이유가 다른 코드는 분리한다**

---

### 🔹 파일 분리의 기준 3 (판단 체크리스트)

### 기준 1) 이 줄에 `input()` / `print()` 가 있나?

- 있으면 → **IO(입출력) 파일로**
    
- 이유: 입출력은 테스트하기 어렵고, UI가 바뀌면 자주 바뀜
    ✅ `io_utils.py`
    
---

### 기준 2) 이 코드는 “프로그램의 규칙(로직)”인가?

- 계산, 판단, 객체 생성, 데이터 가공처럼  
    **“이 프로그램이 어떻게 동작해야 하는지”를 정의하는 코드**
- 입력/출력 방식과 무관하게 항상 같은 규칙을 적용해야 하는 코드

- 이유: 서비스 로직은 콘솔·웹·API 어디서 호출하든  
	동일하게 동작해야 하므로  
	입출력과 분리할수록 테스트와 재사용이 쉬워진다.
    ✅ services.py
---

### 기준 3) 이 코드는 “프로그램의 진행 순서”를 적고 있나?

- while loop, 메뉴, 흐름 제어, 어디 함수부터 호출할지

- 이유: 흐름을 한 눈에 읽게 만들고, 나머지 구현은 위임
    ✅ `main.py`
    
---

### 🔹 나눈 후 디렉터리 구조

```
grade_app/
├── main.py          # 프로그램 시작점 (흐름)
├── models.py        # 데이터 구조 정의
├── services.py      # 로직(계산, 비즈니스 로직)
└── io_utils.py      # 입력/출력 관련 함수
```

---

### 🔹 가장 헷갈려하는 포인트: “어떤 파일에 둬야 하지?”

여기서 가장 효과적인 규칙이 하나 있습니다.

> ✅ “바뀌는 이유”가 같으면 같이 두고, 바뀌는 이유가 다르면 분리한다

예시로 보면:

- 출력 문구를 바꾸고 싶다 → 출력만 바뀜 → `io_utils.py`
- 평균 계산 방식을 바꾸고 싶다 → 계산만 바뀜 → `services.py`
- 입력 흐름을 메뉴형으로 바꾸고 싶다 → main 흐름만 바뀜 → `main.py`

즉, **변경 포인트가 분리되면 유지보수가 쉬워집니다.**

---

### 🔹 파일 분리할 때 좋은 규칙 3가지 (추가 규칙)

1. **위에서 아래로 흐르게(import 방향 고정)**

- `main.py` → `services.py` → `models.py`
- `main.py` → `io_utils.py`
- 아래 파일이 위 파일을 import하게 만들지 말기 (순환 import 방지)

2. **파일 이름은 “역할”이 드러나게**
- `util.py` 보다는 `io_utils.py`, `file_utils.py`, `validators.py` 처럼 구체적으로

3. **“실행 코드”와 “정의 코드”를 섞지 말기**
- 함수/클래스 정의는 모듈에
- `if __name__ == "__main__":` 아래에는 실행만

---

### 🔹 파일 분리 5개 규칙
아래 5개만 지키면 “분리했더니 더 복잡해지는 문제”를 거의 막을 수 있어요.

### 규칙 1) `main.py`는 “스토리만” 적는다

- main은 “무슨 일을 어떤 순서로 하는지”만 보여주는 곳
- 계산/저장/출력의 상세 구현은 다른 파일에 맡긴다

✅ 좋은 main의 느낌

```python
name = input_name()
scores = input_scores()
student = create_student(name, scores)
print_report([student])
```

**이 4줄을 정확히 해석하면**

- `input_name()` 함수 호출 → 반환값을 `name`에 저장
- `input_scores()` 함수 호출 → 반환값(예: `[90, 80, 70]`)을 `scores`에 저장
- `create_student(name, scores)` 함수 호출 → 반환값(Student 객체)을 `student`에 저장
    → 여기서 `student`는 **객체 1개**
    
- `print_report([student])`
    → 함수의 인자로 `[student]` 전달
    → `[student]`는 **Student 객체 1개를 담은 리스트**
    → `print_report()`는 “여러 명의 학생 목록”을 받도록 설계되어 있기 때문
    
전체 흐름을 말로 풀면(의사코드):

1️⃣ 이름을 입력받아 `name`에 저장
2️⃣ 점수 목록을 입력받아 `scores`에 저장
3️⃣ 학생 객체를 만들고 `student`에 저장
4️⃣ 학생 목록(리스트) 형태로 출력 함수에 전달

---

### 규칙 2) `services.py`에는 `print()` / `input()` 금지

- 서비스는 로직만 있어야 테스트가 쉬움
- 콘솔 → 웹/앱/Streamlit로 바뀌어도 재사용 가능

---

### 규칙 3) `io_utils.py`는 “보여주는 것”만 한다

- 출력 형식, 안내 문구, 에러 메시지
- 콘솔 출력 → Streamlit/HTML로 교체할 때 이 레이어만 교체

---

### 규칙 4) “데이터(학생)”는 클래스/딕셔너리로 한 번 정의한다

- 학생 데이터가 여기저기서 제멋대로 생기면 금방 꼬임
- `Student` 같은 모델을 만들면 구조가 고정됨

---

### 규칙 5) import 방향은 위에서 아래로만

> `main.py` → `services.py` → `models.py`
> `main.py` → `io_utils.py`

아래 파일이 위 파일을 import하면
❌ 순환 import(무한 참조)로 터질 수 있음

---

### 🔹 예제 1) 나눈 후: 각 파일 내용

📄 `models.py` – 데이터 구조
```python
# models.py

class Student:
    def __init__(self, name, scores):
        self.name = name
        self.scores = scores  # [국어, 영어, 수학]
        self.avg = sum(scores) / len(scores)
```

---

📄 `services.py` – 로직(데이터 처리)
```python
# services.py

from models import Student

def create_student(name, scores):
    """학생 객체 생성"""
    return Student(name, scores)

def print_report(students):
    """학생 성적 표 출력"""
    print("=== 성적표 ===")
    for s in students:
        print(f"{s.name}: 평균 {s.avg:.1f}점")
```

🧠 포인트(선택 확장):
서비스는 `print` 대신 “문장 리스트(lines)”를 만들어 반환하게 하면 테스트가 쉬워집니다.

---

📄 `io_utils.py` – 입력/출력 유틸
```python
# io_utils.py

def input_scores(subjects):
    scores = []
    for subject in subjects:
        score = int(input(f"{subject} 점수: "))
        scores.append(score)
    return scores
```

---

📄 `main.py` – 프로그램 시작점 / 흐름 제어
```python
# main.py

from services import create_student, print_report
from io_utils import input_scores

def main():
    students = []
    subjects = ["국어", "영어", "수학"]

    while True:
        name = input("이름 (종료:q): ")
        if name == "q":
            break

        scores = input_scores(subjects)
        student = create_student(name, scores)
        students.append(student)

    print_report(students)

if __name__ == "__main__":
    main()
```

---

### 🔹 추가설명: `if __name__ == "__main__":` 는 왜 필요할까?

이 조건문은 **파이썬 프로그램의 동작 방식을 구분**하기 위해 사용합니다.

|상황|`__name__` 값|동작|
|---|---|---|
|해당 파일을 **직접 실행**|`"__main__"`|`main()` 실행됨|
|다른 파일에서 **import**됨|파일 이름(예: `"weather_app"`)|`main()` 실행 ❌|

직접 실행할 때만 main()을 실행하고, import될 땐 실행하지 않기 위한 장치입니다.
예를 들어 아래처럼 import만 했는데,
갑자기 입력을 요구하면 곤란합니다.
```python
import app_before  # 갑자기 사용자 입력을 요구할 수 있음
```

그래서 아래 관용구를 넣습니다.
```python
def main():
    print("메인 실행")

if __name__ == "__main__":
    main()
```

```python
import weather_app  # 아무것도 출력되지 않음
```

쉽게 말하면:

> “이 파일이 직접 실행될 때만 main( )을 실행해라!
> 다른 파일에서 import될 때는 실행하지 마!”

---

### ✏️ 실습 문제: “날씨 알리미” 모듈 나누기

### 1. 미션 설명

아래처럼 하나의 파일에 섞여 있는 코드를,
```
weather_app/
├── main.py        # main() + 입력 반복 (프로그램 흐름)
├── services.py    # get_weather() (날씨 데이터 처리 / 나중에 API로 확장)
└── io_utils.py    # print_weather() (출력 담당)
```

**3개의 파일로 역할을 나누어 보세요.**

- 입력/반복 흐름 → `main.py`
- 날씨 정보 가져오는 로직 → `services.py`
- 출력(화면 표시) 역할 → `io_utils.py`

---

### 2. 문제 원본 코드 (`weather_app.py`)

```python
# weather_app.py
# ----------------------------
# [설명]
# - 도시 이름을 입력하면 해당 도시의 날씨(기온)를 알려주는 간단한 콘솔 앱
# - 아직은 한 파일에 모든 기능이 다 섞여 있음
# ----------------------------

def get_weather(city):
    """도시 이름을 받아 임시 날씨 데이터를 반환하는 함수"""
    dummy_data = {
        "서울": 20,
        "부산": 23,
        "대구": 25,
        "인천": 19,
        "제주": 22,
    }
    return dummy_data.get(city)

def print_weather(city, temp):
    """도시와 온도를 받아서 화면에 출력하는 함수"""
    if temp is None:
        print(f"[알림] {city}의 날씨 정보가 없습니다.")
    else:
        print(f"{city}의 현재 기온은 {temp}도입니다.")

def main():
    print("=== 날씨 알리미 ===")
    print("도시 이름을 입력하면 현재 기온을 알려드립니다.")
    print("종료하려면 q 를 입력하세요.\\n")

    while True:
        city = input("도시 이름 입력 (종료:q): ").strip()
        if city.lower() == "q":
            print("프로그램을 종료합니다.")
            break

        temp = get_weather(city)
        print_weather(city, temp)

if __name__ == "__main__":
    main()
```

---

### ✅ 답안:

### 0. 디렉터리 구조

```
weather_app/
├── main.py        # 프로그램 실행 시작점, 입력 반복
├── services.py    # 날씨 데이터 조회 로직
└── io_utils.py    # 출력 담당
```

---

### 1) `services.py` – 날씨 데이터 조회 로직

```python
# services.py
# 날씨 데이터 조회(비즈니스 로직) 담당

def get_weather(city: str) -> int | None:
    """도시 이름을 받아 임시 날씨 데이터를 반환하는 함수"""
    dummy_data = {
        "서울": 20,
        "부산": 23,
        "대구": 25,
        "인천": 19,
        "제주": 22,
    }
    return dummy_data.get(city)
```

---

### 2) `io_utils.py` – 출력 담당

```python
# io_utils.py
# 출력(프레젠테이션) 담당

def print_weather(city: str, temp: int | None) -> None:
    """도시와 온도를 받아서 화면에 출력하는 함수"""
    if temp is None:
        print(f"[알림] {city}의 날씨 정보가 없습니다.")
    else:
        print(f"{city}의 현재 기온은 {temp}도입니다.")

def print_intro() -> None:
    """프로그램 안내 문구 출력"""
    print("=== 날씨 알리미 ===")
    print("도시 이름을 입력하면 현재 기온을 알려드립니다.")
    print("종료하려면 q 를 입력하세요.\\n")
```

---

### 3) `main.py` – 실행 흐름 / 입력 반복

```python
# main.py
# 프로그램 실행 흐름 담당 (입력 반복 + 서비스 호출)

from services import get_weather
from io_utils import print_weather, print_intro

def main():
    print_intro()

    while True:
        city = input("도시 이름 입력 (종료:q): ").strip()
        if city.lower() == "q":
            print("프로그램을 종료합니다.")
            break

        temp = get_weather(city)
        print_weather(city, temp)

if __name__ == "__main__":
    main()
```

---

### 🧠 포인트 정리 (날씨 예제)

- `services.py`
    → “날씨 데이터를 어떻게 가져오는지”에만 관심
    → 나중에 딕셔너리 → 실제 API(requests)로 바꿔도 **main은 그대로**
    
- `io_utils.py`
    → “어떻게 보여줄지”만 관심
    → 콘솔 출력 → Streamlit/웹 템플릿으로 바꿀 때도 **이 레이어만 교체**
    
- `main.py`
    → 사용자와의 대화 흐름 + 필요한 기능 호출
    → 스토리만 남기고 상세 구현은 다른 파일에 위임
    

---

### 🔹 분리 실전 요령 (가장 쉬운 방법)

파일 나누기가 어려우면 이렇게 하세요.

✅ **3단계 커팅 방법**

1. 먼저 `main()`만 남기기
    - main에 있는 로직 중 계산/출력 코드를 “함수 호출”로 바꾸기
2. `print()` 관련은 전부 `io_utils.py`로 이동
    - `print_intro`, `print_result`, `print_error` …
3. 남은 계산/판단 코드는 `services.py`로 이동
    - `get_weather`, `create_student`, `validate` …

---

## ✅ 마지막 한 문장

> 파일 분리는 어려운 기술이 아니라, 바뀌는 이유가 다른 코드를 떨어뜨려 놓는 습관이다.