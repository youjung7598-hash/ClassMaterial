### 🔹 사용자 정의 모듈 만들기
모듈(module)은 `.py` 확장자를 가진 파이썬 코드 파일이며,
여러 함수, 클래스, 상수 등을 하나의 파일에 정리해두고  
다른 파일에서 `import`를 통해 불러와 반복 없이 재사용할 수 있습니다.

◽ 사용자 정의 모듈을 사용하는 이유
- 기능별로 코드를 분리하여 가독성과 유지보수성이 좋아짐
- 중복되는 코드를 한 번만 작성하고 여러 곳에서 재사용 가능
- 팀 프로젝트에서 역할 분담이 쉬워짐 (파일 단위 작업)

✨ 실무 활용 예:
- `utils.py`
	자주 쓰는 유틸 함수(날짜 처리, 문자열 포맷, 파일 저장 등)를 모아두는 모듈
- `calculator.py`	
	계산 관련 기능만 따로 모아놓은 모듈
- `logger.py`	
	공통 로그 기록 기능을 담당하는 모듈
- `text_analyzer.py`	
	텍스트를 분석하는 독립적 기능의 모듈
- `validators.py`	
	사용자 입력 유효성 검사 함수들을 따로 모아서 관리
- `팀 프로젝트`	
	팀원이 각각 기능별 모듈을 작성하고, 메인 코드에서 import로 연결하여 협업 가능
---
### 🔹 모듈만들기

📄 `mymath.py` : 사용자 정의 모듈 만들기
```python
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

PI = 3.14159
```
이 파일은 모듈입니다.  
`.py` 파일로 저장하고, 함수와 상수를 정리해둡니다.

---
📄 `main.py` : 모듈 불러와서 사용하기
```python
import mymath

result1 = mymath.add(5, 3)
result2 = mymath.subtract(10, 4)

print("덧셈 결과:", result1)
print("뺄셈 결과:", result2)
print("원주율:", mymath.PI)
```

🖨️ 출력 결과:
```python
덧셈 결과: 8
뺄셈 결과: 6
원주율: 3.14159
```
---
### 🔹 __ name __ == "__ main __ __" 조건문
	이 조건문은 파이썬 파일의 실행 방식에 따라 특정 코드의 실행 여부를 
	결정하는 문법입니다.  
	즉, "이 파일이 직접 실행된 것인지, 다른 파일에서 불러온 것인지"를 
	구분하기 위해 사용됩니다.


◽ `__name__`: 
	파이썬이 모든 모듈(파일)을 실행할 때 자동으로 설정하는 내장 변수입니다. 이 변수는 현재 파일이 실행되는 방식에 따라 값이 다르게 설정됩니다.
	
◽ `__main__`: 
	어떤 파이썬 파일을 직접 실행했을 경우,  
    그 파일 안의 `__name__` 변수는 자동으로 `"__main__"`이라는 값을 갖게 됩니다. 반면, 다른 파일에서 import된 경우에는 `__name__`은 그 모듈 이름(파일명)이 됩니다.

---
📄 예시 파일명: `test.py`
```python
print(__name__)
```

터미널에서 `python test.py`로 직접 실행하면:
```python
__main__
```

다른 파일에서 `import test`하면:
```python
test
```
---
◽ 모듈의 `__name__`이란?

- 파이썬의 모듈(파일)은 import될 때 자신의 이름이 `__name__` 변수에 저장됩니다.
- 이를 통해 모듈이 직접 실행된 건지, import된 건지를 구분할 수 있습니다.

---
◽ `__name__` 활용하기

기본 구조
```python
def main():
    print("이 코드는 직접 실행할 때만 동작합니다.")

if __name__ == "__main__":
    main()
```

❓ 왜 이렇게 쓰나요?
- 이 조건문은 "테스트용 실행 코드"와 "재사용할 코드"를 분리하기 위해 자주 사용됩니다.
- 예를 들어, 함수와 클래스를 정의한 파일이 import될 때는 테스트 코드가 실행되지 않도록 막을 수 있습니다.
---
📄 `main_example.py` : 단일 파일에서 직접 실행하는 경우
```python
def greet():
    print("안녕하세요!")

print("파일이 실행되었습니다.")

if __name__ == "__main__":
    print("이 파일이 직접 실행되고 있습니다.")
    greet()
```

🖨️ 출력 결과:
```python
파일이 실행되었습니다.
이 파일이 직접 실행되고 있습니다.
안녕하세요!
```
- 이 파일을 직접 실행하면, `__name__`의 값은 `"__main__"`이 됩니다.
- 따라서 `if __name__ == "__main__":` 아래의 코드도 실행됩니다.
---
📄 `main_example.py` : 모듈로 import 되었을 때
```python
def greet():
    print("안녕하세요!")

print("파일이 실행되었습니다.")

if __name__ == "__main__":
    print("이 파일이 직접 실행되고 있습니다.")
    greet()
```

📄 `other_script.py` : 이 파일에서 위 파일을 import
```python
import main_example
print("외부 파일에서 main_example 모듈을 불러왔습니다.")
```

🖨️ 출력 결과:
```python
파일이 실행되었습니다.
외부 파일에서 main_example 모듈을 불러왔습니다.
```

🔍 설명
- `main_example`이 다른 파일에서 import되면,  
    `main_example.py` 내부의 `__name__`은 `"main_example"`이 됩니다.
- 따라서 `if __name__ == "__main__":` 조건은 거짓(False)이므로  
    `greet()` 함수와 `"이 파일이 직접 실행되고 있습니다."` 출력은 실행되지 않습니다.

---
### 🔹 패키지란?
	패키지(Package)는 관련된 여러 개의 파이썬 모듈(.py 파일)을  
	디렉토리(폴더) 단위로 구조화해 정리하는 방식입니다.

---
◽ 패키지 만들기
	`mathutils`라는 패키지를 만들어서 `add`, `subtract` 기능을 제공하기

1단계: 디렉토리 구조 만들기:
```python
📁 myproject/
├── main.py
├── 📁 mathutils/              ← 패키지
│   ├── __init__.py           ← 패키지임을 알리는 파일
│   ├── add.py                ← 모듈 1
│   └── subtract.py           ← 모듈 2
```

2단계: 각 파일의 내용 작성 
패키지임을 알리는 파일 (비워도 되지만 편의상 직접 import도 가능하게 설정)

📄 `mathutils/__init__.py`
```python
from .add import add
from .subtract import subtract
```

📄 `mathutils/add.py`
```python
def add(a, b):
    return a + b
```

📄 `mathutils/subtract.py`
```python
def subtract(a, b):
    return a - b
```

3단계: 사용 파일 만들기 (`main.py`)

📄 `main.py`
```python
from mathutils import add, subtract

result1 = add(7, 3)
result2 = subtract(7, 3)

print("덧셈 결과:", result1)
print("뺄셈 결과:", result2)
```

4단계: 실행 결과
```python
python main.py
```

🖨️ 출력:
```python
덧셈 결과: 10
뺄셈 결과: 4
```

---
이미 만들어진 패키지 `mathutils` 안의 모듈인 `add`, `subtract`를 가져와서 사용하는 코드

```python
📁 myproject/
├── main.py                # 여기서 import 함
└── 📁 mathutils/          # 패키지 폴더
    ├── __init__.py        # 있어야 패키지로 인식됨
    ├── add.py
    └── subtract.py
```

조건:
- `main.py`와 `mathutils` 폴더는 같은 상위 폴더 안에 있어야 합니다.  
    그래야 `from mathutils import ...` 문장이 동작합니다.
- `mathutils` 폴더 안에 `__init__.py` 파일이 반드시 있어야  
    Python이 이 폴더를 “패키지”로 인식합니다. (비워도 됨)


◽ `mathutils/__init__.py`: 빈 파일이지만 있어야 패키지로 인식됨
```python
# 이 파일은 비워도 됩니다.
```

◽  `mathutils/add.py`
```python
def add(a, b):
    return a + b
```

◽ `mathutils/subtract.py`
```python
def subtract(a, b):
    return a - b
```

◽ `main.py` — 패키지 사용 예
```python
from mathutils import add, subtract

result1 = add.add(10, 5)
result2 = subtract.subtract(10, 5)

print("덧셈 결과:", result1)
print("뺄셈 결과:", result2)
```
- `main.py`가 실행될 때 Python은 현재 디렉토리(즉, `main.py`가 있는 위치)를 기준으로  `mathutils` 폴더를 찾고, 그 안에서 `add.py`, `subtract.py` 모듈을 가져옵니다.

🖨️ 출력 결과:
```python
덧셈 결과: 15
뺄셈 결과: 5
```
---

|구분|만들 때 (`패키지 정의`)|가져다 쓸 때 (`사용`)|
|---|---|---|
|역할|패키지 구조를 설계하고 기능을 모듈로 나눔|만들어진 기능을 불러다 사용|
|구조|폴더 + `__init__.py` + 모듈 `.py` 파일|폴더 외부에서 import 사용|
|import 위치|같은 프로젝트 내부이거나, 자신이 만든 패키지를 테스트|외부 사용자 또는 메인 프로그램|
|핵심 작업|기능 쪼개기 + 내보내기 (`__init__.py` 구성)|기능 호출 (`from ... import ...`)|
|예시|`mathutils/add.py` 안에 `def add()` 정의|`from mathutils import add`로 호출|
패키지를 만든다 → 도구(연필, 자, 가위)를 정리해서 **도구함**을 만든 것
패키지를 사용한다 → 그 도구함에서 꺼내서 도구를 사용하는 사람

```python
# 패키지 제작자 관점 (도구함 만들기)
def add(a, b):
    return a + b
```

```python
# 사용자 관점 (도구 꺼내쓰기)
from mathutils import add
print(add(3, 4))
```
---
📝 문제1] 다음 중 패키지를 만들기 위한 필수 조건으로 올바른 것은?

A. 모듈 내부에 `__main__.py` 파일이 있어야 한다.  
B. 모듈마다 반드시 클래스가 하나 이상 있어야 한다.  
C. 폴더 안에 `__init__.py` 파일이 존재해야 한다.  
D. 패키지는 무조건 pip로 설치되어야 한다.

✅ 정답: C
`__init__.py` 파일이 있어야 Python은 해당 폴더를 패키지로 인식합니다.

📝 문제2] 아래 코드에서 `add.add(3, 5)`가 실행되기 위해 필요한 구성으로 가장 적절한 것은?
```python
from mathutils import add

result = add.add(3, 5)
```

A. `add.py` 파일이 mathutils 폴더 밖에 있어야 한다.  
B. `add.py` 안에 `add()` 함수가 정의되어 있어야 한다.  
C. `add.py`는 `main.py`와 같은 폴더에 있어야 한다.  
D. `mathutils`는 zip 파일로 압축되어 있어야 한다.

✅ 정답: B
`from mathutils import add`는 `mathutils/add.py` 모듈을 import하는 것이므로,  그 안에 `add()` 함수가 정의되어 있어야 합니다.

📝 문제3] 다음 중 패키지를 만든 사람이 해야 할 일로 가장 적절한 것은?

A. 필요한 함수를 정의하고, 관련 모듈들을 디렉토리에 정리한다.  
B. 패키지를 사용하기 위해 from-import 구문을 작성한다.  
C. pip install로 외부 모듈을 설치한다.  
D. 패키지를 실행하기 위한 main.py를 항상 포함해야 한다.

✅ 정답: A
패키지를 만드는 사람은 기능별로 모듈을 나누고, 디렉토리를 구성하며 `__init__.py`를 준비합니다.

📝 문제4] 패키지를 사용하려면 어떤 전제 조건이 필요한가?

A. 항상 관리자 권한으로 실행해야 한다.  
B. `main.py`와 패키지 폴더가 같은 디렉토리에 있어야 한다.  
C. 사용하려는 모듈의 이름은 반드시 `main.py`여야 한다.  
D. 사용 전에 `compile()` 함수로 모듈을 빌드해야 한다.

✅ 정답: B
`from mathutils import add` 와 같은 사용을 하려면 `main.py`와 `mathutils/`가 같은 경로에 있어야 Python이 import할 수 있습니다.

📝 문제5] 아래 구조를 보고 `main.py`가 패키지를 import할 수 없는 이유는?

```python
📁 myproject/
├── main.py
└── 📁 mathutils/
    ├── add.py
    └── subtract.py
```

A. `main.py`에서 import는 지원되지 않기 때문이다.  
B. add.py에 `add()` 함수가 없기 때문이다.  
C. `mathutils/` 안에 `__init__.py` 파일이 없기 때문이다.  
D. 모듈 이름은 모두 대문자로 써야 하기 때문이다.

✅ 정답: C
`__init__.py`가 없으면 Python은 `mathutils`를 단순한 폴더로 취급하고 패키지로 인식하지 않습니다.

---

### 🔹모듈작성 역할분담

✅ 예시1] 블로그 웹 애플리케이션
###### 팀 역할 분담
|팀원|역할|작성할 모듈 파일|
|---|---|---|
|A|게시글 기능|`post_module.py`|
|B|댓글 기능|`comment_module.py`|

📁 각 모듈 작성
`post_module.py`
```python
def create_post(title, content):
    print(f"[POST] 제목: {title}")
    print(f"[POST] 내용: {content}")
```

`comment_module.py`
```python
def add_comment(post_id, comment):
    print(f"[COMMENT] 게시글 {post_id}에 댓글 추가: {comment}")
```

</> main.py (통합 메인 코드)
```python
from post_module import create_post
from comment_module import add_comment

# 게시글 작성
create_post("장고 모듈화", "유지보수가 쉬워요!")

# 댓글 추가
add_comment(1, "좋은 글 감사합니다!")
```
---
✅ 예시2] 데이터 분석 파이프라인 프로젝트
###### 팀 역할 분담
| 팀원  | 역할      | 작성할 모듈 파일           |
| --- | ------- | ------------------- |
| C   | 데이터 수집  | `data_collector.py` |
| D   | 데이터 시각화 | `visualizer.py`     |

📁 각 모듈 작성
`data_collector.py`
```python
def collect_data():
    print("데이터 수집 완료")
    return [10, 20, 30, 40]
```

`visualizer.py`
```python
def draw_chart(data):
    print(f"차트 데이터: {data}")
```

</> main.py (통합 메인 실행 파일)
```python
from data_collector import collect_data
from visualizer import draw_chart

data = collect_data()
draw_chart(data)
```

💡 요약
- 팀원별로 기능별 모듈을 나누면 병렬 작업이 가능해 협업에 유리합니다.
- `main.py`나 `views.py` 같은 중심 파일에서 각 기능을 불러와 사용합니다.
- Django 프로젝트에서도 `utils`, `services`, `validators` 폴더로 나눠 쓰는 것과 같은 방식입니다.

---
📝 문제1] 다음 중 모듈을 여러 개로 나누어 작성하는 주된 이유는?

A. 프로그램이 느려지기 때문  
B. 코드를 여러 폴더에 숨기기 위해  
C. 기능별로 역할을 분리하고 코드의 재사용성과 유지보수성을 높이기 위해  
D. 파이썬에서는 한 파일에 클래스 1개만 있어야 하기 때문에

✅ 정답: C
모듈화는 기능별로 코드를 나누어 관리, 유지보수 용이성, 재사용성 향상이라는 큰 장점이 있습니다.


📝 문제2] 아래 보기 중 모듈의 역할 분담 방식으로 가장 적절한 예는?

A. 모든 기능을 하나의 `main.py`에 작성한다.  
B. 계산 기능은 `math_utils.py`, 출력 기능은 `display.py`로 분리한다.  
C. 여러 개의 모듈이 동일한 함수 이름을 사용하도록 작성한다.  
D. 모듈에는 변수만 정의하고 함수는 작성하지 않는다.

✅ 정답: B
기능별 역할(계산 vs 출력)을 나누어 책임을 분리하는 것이 모듈화의 핵심입니다.


📝 문제3] 모듈 간 역할이 잘 분리되었을 때 얻을 수 있는 이점으로 가장 적절한 것은?

A. import 문을 쓰지 않아도 된다.  
B. 하나의 기능만 수정해도 전체 파일을 전부 수정해야 한다.  
C. 특정 기능만 독립적으로 테스트하거나 교체하기 쉽다.  
D. 여러 개발자가 동시에 같은 파일을 수정해야 한다.

✅ 정답: C 
모듈화된 구조는 기능별로 분리되어 있어 부분 테스트, 수정, 재사용이 훨씬 쉬워집니다.
