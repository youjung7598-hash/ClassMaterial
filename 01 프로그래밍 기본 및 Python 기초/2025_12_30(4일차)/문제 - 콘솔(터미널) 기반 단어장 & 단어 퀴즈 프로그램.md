프로젝트 코드명: `VocaTrainer`
프로젝트 유형: 콘솔(터미널) 기반 단어장 & 단어 퀴즈 프로그램

## 🖥️ 프로젝트 개요

- 사용자가 영어 단어와 한국어 뜻을 직접 등록하고,
- 등록된 단어 목록을 확인한 뒤,
- 무작위로 출제되는 단어 퀴즈를 풀어보는 프로그램입니다.

아래 기능을 모두 연습해보는 활용문제입니다.
- 자료형(list, dict, str),
- 문자열 처리,
- 조건문/반복문,
- 함수,
- 클래스 & 객체,
- 모듈(import)

##### 📚 이 프로젝트를 통해 자연스럽게 적용되는 내용
|항목|사용되는 예시|
|---|---|
|자료형 (list, dict, str)|단어 목록을 리스트로 관리, 단어/뜻을 문자열로 저장|
|문자열 연산 / 메서드|`strip()`, `lower()`, f-string 출력, `"정답/오답" 메시지 구성`|
|조건문 (`if`, `elif`, `else`)|메뉴 선택 분기, 정답/오답 판별, 종료 조건 처리|
|반복문 (`for`, `while`)|메인 메뉴 무한 반복, 퀴즈에서 여러 문제 연속 출제|
|함수 (`def`)|메뉴 출력 함수, 단어 추가 함수, 퀴즈 실행 함수로 분리|
|클래스 (`class`)|`Word`(단어 1개), `VocabBook`(단어장) 클래스로 객체지향 연습|
|객체 생성 및 메서드 호출|`Word(...)`, `VocabBook()` 객체를 만들어 `add_word`, `get_quiz_list` 호출|
|모듈 (`import`)|`vocab_models.py` 모듈을 만들어, `app.py`에서 `from vocab_models import ...`|

##### 📄 기능 요구사항 (Functional Requirements)
|기능ID|기능설명|세부내용|
|---|---|---|
|F-01|단어 추가|사용자에게 영어 단어와 한국어 뜻을 입력받아 단어장에 추가한다. 공백을 제거하고, 이미 존재하는 단어면 안내 메시지를 출력한다.|
|F-02|단어 목록 조회|현재 등록된 모든 단어를 `번호. 영어 - 한국어` 형태로 출력한다. 단어가 없으면 “등록된 단어가 없습니다” 메시지를 출력한다.|
|F-03|단어 퀴즈 (영→한)|단어장에서 무작위로 N개(기본 5개)를 뽑아 영어 단어를 제시하고, 사용자가 한국어 뜻을 입력하면 정답/오답을 판정한다. 최종 점수(맞춘 개수/전체)를 출력한다.|
|F-04|단어 기본 세트 로딩|프로그램 시작 시, 예시로 사용할 기본 단어 5개를 자동으로 단어장에 넣어준다. (사용자는 여기에 추가로 등록 가능)|
|F-05|메뉴 화면 및 종료 기능|1) 단어 추가 2) 단어 목록 보기 3) 퀴즈 풀기 0) 종료 메뉴를 반복적으로 보여주고, 0을 선택하면 프로그램을 종료한다.|
|F-06|퀴즈 결과 요약|퀴즈를 한 번 끝낸 후 맞은/틀린 문제 수, 정답률(%)을 간단히 출력한다.|

##### 📄 비기능 요구사항 (Non-Functional Requirements)
|항목|설명|
|---|---|
|사용성(Usability)|초보자도 이해할 수 있도록 메뉴와 안내 문구를 한국어로 출력하고, 잘못된 입력에 대해 재입력을 요청한다.|
|유지보수성|`클래스 정의`와 `실행 로직`을 서로 다른 파일(모듈)로 분리하여 구조를 깔끔하게 유지한다.|
|가독성|함수와 클래스에 간단한 주석과 docstring을 작성하고, 의미 있는 변수명(예: `vocab_book`, `user_choice`)을 사용한다.|
|확장성|나중에 “한→영 퀴즈 모드”, “파일로 저장하기” 기능을 추가하기 쉽도록, 단어 처리 로직을 `VocabBook` 클래스로 묶는다.|
|안정성|단어가 하나도 없는데 퀴즈를 시작하려 하면, 에러 대신 “단어를 먼저 등록하세요”와 같은 안내 메시지를 출력한다.|

✅ 출력 포맷 구성1 (예시 실행 화면)
```text
=========================
📘 VocaTrainer - 단어장
=========================

1) 단어 추가
2) 단어 목록 보기
3) 단어 퀴즈 풀기 (영 → 한)
4) 종료
메뉴를 선택하세요: 2

[ 현재 단어 목록 ]
1. apple  - 사과
2. book   - 책
3. computer - 컴퓨터

계속하려면 엔터를 누르세요...

=========================
📘 VocaTrainer - 단어장
=========================

1) 단어 추가
2) 단어 목록 보기
3) 단어 퀴즈 풀기 (영 → 한)
4) 종료
메뉴를 선택하세요: 3

출제할 문제 수를 입력하세요 (기본: 5): 3

[문제 1] apple 의 뜻은?
> 사과
✅ 정답입니다!

[문제 2] book 의 뜻은?
> 노트
❌ 오답입니다. 정답: 책

[문제 3] computer 의 뜻은?
> 컴퓨터
✅ 정답입니다!

📊 퀴즈 결과
- 맞은 개수: 2 / 3
- 정답률: 66.7 %

계속하려면 엔터를 누르세요...
```

✅ 정답 코드
	같은 폴더에 **`vocab_models.py`** 와 **`app.py`** 두 파일로 구성해서 연습해보세요.

1) `vocab_models.py`
```python
# -----------------------------------------
# 이 파일은 "단어장 + 단어 퀴즈" 프로그램에서
#   - 단어 1개를 나타내는 Word 클래스
#   - 단어 여러 개를 관리하는 VocabBook 클래스
#   - 기본 단어들이 들어 있는 단어장 생성 함수
# 를 모아 둔 "모델 모듈"입니다.
# 실제 실행(메뉴, 입력/출력)은 app.py에서 하고,
# 이 파일은 "데이터 구조 + 로직"만 담당한다고 보면 됩니다.

from __future__ import annotations
# ↑ Python 3.7~3.10 등에서 클래스 안에서 자기 자신 타입을
#   타입힌트로 쓸 때 문제 없게 해주는 설정입니다.
#   (3.11 이상에서는 없어도 되지만, 호환성을 위해 넣어둔 예시라고 이해하면 됩니다)

from dataclasses import dataclass, field
# dataclass: 클래스를 "데이터 보관용"으로 쉽게 만들게 해주는 데코레이터
# field: dataclass 안에서 기본값이 리스트/딕셔너리일 때 안전하게 쓰기 위해 사용

from typing import List
# List[타입] 처럼 "리스트 안에 어떤 타입이 들어가는지"를 적는 타입 힌트용

import random
# random: 퀴즈 출제 시 단어를 랜덤으로 섞거나 뽑을 때 사용


# -----------------------------------------
# Word 클래스: "영어 단어 1개"를 표현
# -----------------------------------------
@dataclass
class Word:
    """영어 단어 1개를 표현하는 클래스"""
    # 영어 단어 (예: "apple")
    english: str
    # 한국어 뜻 (예: "사과")
    korean: str
    # 지금까지 퀴즈에서 맞춘 횟수
    correct_count: int = 0
    # 지금까지 퀴즈에서 틀린 횟수
    wrong_count: int = 0

    def check_answer(self, user_answer: str) -> bool:
        """
        사용자가 입력한 한국어 뜻이 정답인지 확인하는 메서드.

        매개변수:
            user_answer: 사용자가 콘솔에서 입력한 문자열(한국어 뜻)

        반환값:
            True  -> 정답
            False -> 오답

        부가 기능:
            - 정답이면 correct_count 1 증가
            - 오답이면 wrong_count 1 증가
        """
        # 사용자가 입력한 답에서 앞뒤 공백 제거
        normalized_user = user_answer.strip()
        # 우리가 저장해둔 정답(한국어 뜻)도 앞뒤 공백 제거
        normalized_answer = self.korean.strip()

        # 두 문자열이 같으면 정답 처리
        if normalized_user == normalized_answer:
            self.correct_count += 1  # 맞춘 횟수 1 증가
            return True
        else:
            self.wrong_count += 1    # 틀린 횟수 1 증가
            return False


# -----------------------------------------
# VocabBook 클래스: "단어 여러 개"를 관리
# -----------------------------------------
@dataclass
class VocabBook:
    """단어 여러 개를 관리하는 단어장 클래스"""

    # words: Word 객체들을 담는 리스트
    # field(default_factory=list)를 써서
    #   *기본값이 []인 리스트*가 각 인스턴스마다 따로 생성되게 함
    words: List[Word] = field(default_factory=list)

    def add_word(self, english: str, korean: str) -> bool:
        """
        단어장에 새 단어를 추가하는 메서드.

        매개변수:
            english: 영어 단어 (예: "apple")
            korean : 한국어 뜻 (예: "사과")

        반환값:
            True  -> 단어 추가 성공
            False -> 이미 같은 영어 단어가 있어서 추가 실패

        동작 요약:
            1) 영어/한국어 앞뒤 공백 제거
            2) 영어는 소문자로 통일 (중복 체크 용이)
            3) 이미 존재하는 단어인지 검사
            4) 없으면 Word 인스턴스 생성 후 리스트에 추가
        """
        # 입력받은 단어의 앞뒤 공백 제거 + 영어는 소문자로 통일
        english = english.strip().lower()
        korean = korean.strip()

        # 이미 단어장에 같은 영어 단어가 있는지 확인
        for w in self.words:
            # w.english.lower() 로 비교해서, 대소문자 차이를 무시
            if w.english.lower() == english:
                # 이미 있다면 False 반환 (추가 실패)
                return False

        # 반복문을 모두 지나쳤다면, 중복 단어 없음
        # 새 Word 객체를 만들어 리스트에 집어넣기
        self.words.append(Word(english=english, korean=korean))
        return True

    def get_all_words(self) -> List[Word]:
        """
        현재 등록된 모든 단어 리스트를 그대로 반환.
        외부(app.py)에서 단어 목록을 출력할 때 사용.
        """
        return self.words

    def get_quiz_list(self, num_questions: int) -> List[Word]:
        """
        퀴즈에 사용할 단어 리스트를 랜덤으로 골라서 반환하는 메서드.

        매개변수:
            num_questions: 출제하고 싶은 문제(단어) 개수

        동작 요약:
            - 단어장이 비어 있으면 빈 리스트 반환
            - 요청 개수가 단어 수 이상이면: 전체 단어를 섞어서 반환
            - 그보다 작다면: random.sample()로 원하는 개수만큼 랜덤 추출

        반환값:
            List[Word]  -> 퀴즈에 사용할 Word 객체들 리스트
        """
        # 단어장이 비어 있는 경우
        if not self.words:
            return []

        # 요청한 문제 수가 현재 단어 개수보다 크거나 같으면
        if num_questions >= len(self.words):
            # 단어 전체를 복사해서(shallow copy) 섞은 뒤 반환
            shuffled = self.words[:]   # [:]는 리스트 복사
            random.shuffle(shuffled)   # 원본 말고 복사본 섞기
            return shuffled
        else:
            # random.sample(리스트, 개수) -> 중복 없이 일부만 랜덤 추출
            return random.sample(self.words, num_questions)


# -----------------------------------------
# 기본 단어장 생성 함수
# -----------------------------------------
def create_default_vocab_book() -> VocabBook:
    """
    예시 단어 5개가 들어 있는 기본 단어장을 만들어서 반환.

    이 함수는:
        - VocabBook 인스턴스를 하나 만들고
        - 미리 정해둔 단어 목록(default_words)을 차례로 추가한 다음
        - 완성된 VocabBook을 리턴합니다.

    프로그램이 시작할 때 '샘플 데이터'로 사용하기 좋습니다.
    """
    # 빈 단어장 하나 생성
    book = VocabBook()

    # 기본 단어 5개 (튜플 리스트)
    default_words = [
        ("apple", "사과"),
        ("book", "책"),
        ("computer", "컴퓨터"),
        ("teacher", "선생님"),
        ("python", "파이썬"),
    ]

    # for문으로 돌면서 하나씩 단어장에 추가
    for eng, kor in default_words:
        book.add_word(eng, kor)

    # 완성된 단어장을 반환
    return book


# -----------------------------------------
# 이 파일을 "직접 실행"했을 때만 도는 테스트 코드
# -----------------------------------------
# 예)
#   python vocab_models.py
# 이렇게 실행하면 아래 코드가 돌아가고,
#   python app.py
# 처럼 다른 파일에서 import 할 때는 실행되지 않습니다.
if __name__ == "__main__":
    # 기본 단어가 들어 있는 단어장 생성
    vb = create_default_vocab_book()

    # 단어장에 들어 있는 모든 단어 출력
    for w in vb.get_all_words():
        print(f"{w.english} - {w.korean}")
        # 예: apple - 사과
```

2) `app.py`
```python
# app.py
# -----------------------------------------
# 이 파일은 프로그램의 "실행 시작점"입니다.
# - 화면에 메뉴를 보여주고
# - 사용자의 입력을 받아서
# - vocab_models.py 안의 기능들을 사용해서
#   단어 추가 / 목록 보기 / 퀴즈 풀기를 합니다.
# -----------------------------------------

from vocab_models import VocabBook, create_default_vocab_book
# vocab_models.py 파일에서 만든
#   - VocabBook 클래스
#   - create_default_vocab_book 함수
# 를 가져와서 사용합니다.
# (같은 폴더에 vocab_models.py 파일이 있어야 합니다)


# -----------------------------------------
# 1. 화면 상단 제목 출력 함수
# -----------------------------------------
def print_title() -> None:
    # ========== 이런 줄을 25개 출력
    print("=" * 25)
    # 프로그램 제목 출력 (이모지 포함)
    print("📘 VocaTrainer - 단어장")
    print("=" * 25)
    # 한 줄 띄우기
    print()


# -----------------------------------------
# 2. 메뉴 목록 출력 함수
# -----------------------------------------
def print_menu() -> None:
    # 사용자가 선택할 메뉴들을 보여줌
    print("1) 단어 추가")
    print("2) 단어 목록 보기")
    print("3) 단어 퀴즈 풀기 (영 → 한)")
    print("0) 종료")


# -----------------------------------------
# 3. "엔터를 누르세요" 대기 함수
# -----------------------------------------
def wait_for_enter() -> None:
    # 아무 내용도 사용하지 않고, 단지 "잠깐 멈춤" 용도로 사용
    input("\n계속하려면 엔터를 누르세요...")


# -----------------------------------------
# 4. 메뉴 1) 단어 추가 기능
# -----------------------------------------
def handle_add_word(vocab_book: VocabBook) -> None:
    """
    단어를 한 개 입력 받아서 단어장(VocabBook)에 추가하는 역할.
    """
    print("\n[ 단어 추가 ]")

    # 영어 단어 입력받기 (strip()으로 앞뒤 공백 제거)
    eng = input("영어 단어를 입력하세요: ").strip()
    # 한국어 뜻 입력받기
    kor = input("한국어 뜻을 입력하세요: ").strip()

    # 둘 중 하나라도 빈 문자열이면 (즉, 아무것도 안 썼으면)
    if not eng or not kor:
        print("⚠️ 단어와 뜻을 모두 입력해야 합니다.")
        # 함수를 여기서 끝내고 메인 메뉴로 돌아감
        return

    # VocabBook의 add_word 메서드 호출
    # - 성공하면 True, 같은 영어 단어가 이미 있으면 False
    success = vocab_book.add_word(eng, kor)

    if success:
        # f-string: 문자열 안에 {변수} 값을 넣어서 출력
        print(f"✅ '{eng} - {kor}' 단어가 추가되었습니다.")
    else:
        print(f"⚠️ '{eng}' 단어는 이미 등록되어 있습니다.")


# -----------------------------------------
# 5. 메뉴 2) 단어 목록 보기 기능
# -----------------------------------------
def handle_show_words(vocab_book: VocabBook) -> None:
    """
    현재 단어장에 들어 있는 모든 단어를 출력.
    """
    print("\n[ 단어 목록 보기 ]")

    # 단어장 객체에서 전체 단어 리스트 가져오기
    words = vocab_book.get_all_words()

    # 단어가 하나도 없으면 안내 메시지만 출력
    if not words:
        print("⚠️ 아직 등록된 단어가 없습니다.")
        return

    print("\n[ 현재 단어 목록 ]")
    # enumerate: (인덱스, 값) 쌍을 함께 가져오는 함수
    # start=1 을 주면 번호가 1부터 시작 (0이 아니라)
    for idx, w in enumerate(words, start=1):
        # 예: "1. apple  - 사과"
        print(f"{idx}. {w.english}  - {w.korean}")


# -----------------------------------------
# 6. 메뉴 3) 단어 퀴즈 기능
# -----------------------------------------
def handle_quiz(vocab_book: VocabBook) -> None:
    """
    단어장을 이용해서 "영어 → 한국어" 퀴즈를 출제하고 채점하는 함수.
    """
    print("\n[ 단어 퀴즈 (영 → 한) ]")

    # 단어가 하나도 없으면 퀴즈를 할 수 없음
    if not vocab_book.get_all_words():
        print("⚠️ 단어가 없습니다. 먼저 단어를 추가해주세요.")
        return

    # 몇 문제를 풀 것인지 사용자에게 입력 받기
    raw = input("출제할 문제 수를 입력하세요 (기본: 5): ").strip()

    # 사용자가 그냥 엔터만 치면 기본값 5개 문제
    if raw == "":
        num_questions = 5
    else:
        # 숫자가 아닌 문자열을 입력하면 에러 대신 안내 메시지
        if not raw.isdigit():
            print("⚠️ 숫자로 입력해야 합니다.")
            return

        # 문자열을 정수로 변환
        num_questions = int(raw)

        # 0 이하의 숫자를 입력한 경우도 잘못된 입력
        if num_questions <= 0:
            print("⚠️ 1 이상의 숫자를 입력해야 합니다.")
            return

    # 여기까지 왔으면 num_questions 는 올바른 정수
    # VocabBook에서 퀴즈용 단어 리스트를 받아옴
    quiz_list = vocab_book.get_quiz_list(num_questions)

    # 맞힌 문제 수
    correct = 0
    # 전체 문제 수 (실제로 출제된 단어 개수)
    total = len(quiz_list)

    # quiz_list의 각 단어를 하나씩 꺼내며 퀴즈 출제
    for i, word in enumerate(quiz_list, start=1):
        print(f"\n[문제 {i}] {word.english} 의 뜻은?")
        # 사용자의 답 입력
        user_answer = input("> ")

        # Word 객체의 check_answer 메서드를 사용해 정답 여부 확인
        if word.check_answer(user_answer):
            print("✅ 정답입니다!")
            correct += 1  # 맞은 개수 증가
        else:
            print(f"❌ 오답입니다. 정답: {word.korean}")

    # 정답률 계산 (0으로 나누는 오류 방지용)
    if total > 0:
        rate = (correct / total) * 100
    else:
        # 이 경우는 거의 없지만, 혹시 몰라서 0.0으로 처리
        rate = 0.0

    # 퀴즈 결과 요약 출력
    print("\n📊 퀴즈 결과")
    print(f"- 맞은 개수: {correct} / {total}")
    print(f"- 정답률: {rate:.1f} %")


# -----------------------------------------
# 7. main 함수: 프로그램 전체 흐름
# -----------------------------------------
def main() -> None:
    """
    프로그램 시작점.
    - 기본 단어장이 들어 있는 VocabBook을 준비하고
    - 무한 반복으로 메뉴를 보여주며
    - 사용자의 선택에 따라 각 기능 함수(handle_*)를 호출한다.
    """
    # 예시 단어 5개가 들어 있는 단어장 생성
    vocab_book = create_default_vocab_book()

    # 무한 반복: 사용자가 0(종료)를 누를 때까지 계속
    while True:
        # 화면 처음에 제목 + 메뉴 표시
        print_title()
        print_menu()

        # 사용자에게 메뉴 번호 입력 받기
        choice = input("메뉴를 선택하세요: ").strip()

        # 입력값에 따라 다른 기능 수행
        if choice == "1":
            # 1번: 단어 추가
            handle_add_word(vocab_book)
            wait_for_enter()

        elif choice == "2":
            # 2번: 단어 목록 보기
            handle_show_words(vocab_book)
            wait_for_enter()

        elif choice == "3":
            # 3번: 단어 퀴즈 풀기
            handle_quiz(vocab_book)
            wait_for_enter()

        elif choice == "0":
            # 0번: 프로그램 종료
            print("프로그램을 종료합니다. 👋")
            break  # while True 탈출

        else:
            # 0,1,2,3 이 아닌 값을 입력한 경우
            print("⚠️ 잘못된 입력입니다. 0~3 사이의 숫자를 입력하세요.")
            wait_for_enter()


# -----------------------------------------
# 8. 이 파일을 직접 실행했을 때만 main() 호출
# -----------------------------------------
# python app.py 로 실행하면 __name__ 이 "__main__" 이고,
# 다른 파일에서 import 할 때는 "__main__" 이 아니기 때문에
# 아래 main() 함수는 자동으로 실행되지 않습니다.
if __name__ == "__main__":
    main()
```
1. 파일 두 개 만들고 (`vocab_models.py`, `app.py`)
2. 터미널에서 `python app.py` 실행

바로 이 부분이
```python
if __name__ == "__main__":
    main()
```
	이 파일을 프로그램의 시작점으로 실행할지 말지를 결정하는 핵심 코드입니다

한 줄씩 다시 풀어서 보면

1️⃣ `__name__` 이란?
파이썬이 파일을 실행할 때,  
각 파일마다 특별한 변수 `__name__` 을 자동으로 넣어줘요.

- 직접 실행한 파일
```
python app.py
```

그 파일 안에서는:
```python
__name__ == "__main__"
```

다른 파일에서 import 된 파일
```python
import app
```

그 파일 안에서는:
```python
__name__ == "app"
```

2️⃣ 그래서 이 조건문은 이렇게 읽어요
```python
if __name__ == "__main__":
```
➡️ 이 파일이 직접 실행된 경우에만 아래 코드를 실행하라.

즉
```python
main()   # 프로그램을 실제로 시작!
```

왜 이렇게 쓰는 걸까?
import 될 때는 실행되면 안 되고, 직접 실행할 때만 “시작점”이 되게 하려고 입니다.

예를 들어
```python
python app.py     # → main() 실행됨 (프로그램 시작)
```

하지만
```python
from app import main
```
같이 다른 파일에서 가져올 때는:
- 코드가 자동 실행되지 않고
- `main()` 을 원할 때만 호출할 수 있게 됩니다.


---
콘솔 프로그램의 흐름을 이렇게 볼 수 있어요:
```
[시작] 
   ↓
[메뉴 출력]
   ↓
[사용자 입력]
   ↓
[조건 판단 (어떤 기능 실행할지?) ]
   ↓
[기능 실행 (단어 추가 / 목록 / 퀴즈 등)]
   ↓
[다시 메뉴 ... 반복]
```

🗂️ 파일별 역할을 여기에 매칭하면
1️⃣ vocab_models.py (핵심 기능/로직 담당)

###### 이 파일은 “기능 그 자체” 를 담당합니다.
|역할|예|
|---|---|
|데이터 구조 정의|Word, VocabBook|
|단어 추가 로직|`add_word()`|
|목록 제공|`get_all_words()`|
|퀴즈용 랜덤 선택|`get_quiz_list()`|
|정답 확인|`check_answer()`|
즉, 메뉴를 누르면 실제로 일하는 엔진(머리)에 해당합니다.
✔ 메뉴가 있든 없든,  
✔ 콘솔이든,  
✔ 나중에 웹 서비스가 되든,
이 코드는 그대로 재사용할 수 있어요.

---
2️⃣ app.py (🎮 **사용자 흐름/인터페이스 담당**)
이 파일은 사용자와 대화하며 흐름을 컨트롤하는 역할입니다.

|파이프라인 단계|app.py 역할|
|---|---|
|시작|`main()`|
|메뉴 출력|`print_menu()`|
|입력 받기|`input()`|
|조건 판단|`if choice == ...:`|
|기능 실행|`handle_add_word()`, `handle_show_words()`, `handle_quiz()`|
|반복 제어|`while True:`|
app.py 는 리모컨이고
vocab_models.py 는 TV 내부 회로라고 보면 딱 맞습니다.

---
🧩 파이프라인을 “작은 단위”로 쪼개 보면

🔹 1단계 — 프로그램 시작
```
app.py
└──main()
```
---
🔹 2단계 — 메뉴 출력
```
print_title()
print_menu()
```
---
🔹 3단계 — 사용자 입력
```
choice = input("메뉴를 선택하세요: ")
```
---
🔹 4단계 — 조건 판단 (분기)
```
if choice =="1": ...
elif choice =="2": ...
elif choice =="3": ...
elif choice =="0": ...
```
---
🔹 5단계 — 기능 실행 (여기서 모델 호출)

예) 단어 추가
```
handle_add_word()
    └── vocab_book.add_word()   ← vocab_models.py 코드 실행
```

예) 퀴즈
```
handle_quiz()
    ├── vocab_book.get_quiz_list()
    └── word.check_answer()
```
---
🎯 이제 질문에 바로 답하면
	❓ 시작과 메뉴 출력, 선택 입력, 조건 판단으로 나누면 어디?

| 파이프라인 단계     | 위치                                              |
| ------------ | ----------------------------------------------- |
| 시작           | app.py (`main()` + `if __name__ == "__main__"`) |
| 메뉴 출력        | app.py (`print_menu()`)                         |
| 선택 입력        | app.py (`input()`)                              |
| 조건 판단        | app.py (`if choice == ...`)                     |
| 기능 구현(실제 작업) | vocab_models.py + 일부 handle 함수                  |

---
💡 왜 이렇게 나누는 게 중요할까?

👉 이것이 바로 현업 구조입니다.

| 잘못된 구조              | 좋은 구조            |
| ------------------- | ---------------- |
| 모든 코드가 app.py에 몰려있음 | “흐름”과 “기능”이 분리됨  |
| 유지보수 어려움            | 테스트, 확장 쉬움       |
| 나중에 웹/앱 전환시 전체 수정   | 모델 코드 그대로 재사용 가능 |

예를 들어,
나중에 웹 버전으로 바꾸면:
- `app.py` → Django/FastAPI 컨트롤러로 교체
- `vocab_models.py` → 그대로 사용 

---
`1.` 프로그램을 짤 때 _항상_ 존재해야 하는 것 3가지
	
어떤 언어, 어떤 종류의 프로그램이든 무조건 이 3가지는 있어요
1. 데이터(무엇을 다루는가?)
    - 예: 단어, 점수, 유저, 게시글, 주문, 계좌…
2. 로직/기능(데이터를 어떻게 바꾸는가?)
    - 예: 단어 추가, 삭제, 검색, 퀴즈 출제, 로그인, 결제 처리…
3. 흐름(Flow) & 인터페이스(언제 무엇을 호출할까?)
    - 예: 메뉴 보여주기 → 입력 받기 → 어떤 기능 호출할지 결정 → 결과 보여주기

조금 더 초보자 버전으로 말하면:
	데이터 + 기능 + 순서(흐름) 이 세 가지가 항상 필요합니다.

지금 만든 `VocaTrainer`는 이렇게 대응돼요:
- 데이터 → `Word`, `VocabBook` (vocab_models.py)
- 기능 → `add_word`, `get_quiz_list`, `check_answer` 등
- 흐름/순서 → `main`, `handle_*`, `while True`, 메뉴 app.py

---
`2.` 프로그래밍을 할때 꼭 알아야 할 “기능 1개 파이프라인” 패턴
	
기능 하나를 구현할 때마다 이 5단계를 머릿속에서 돌리면 좋아요
1. 트리거(Trigger)
    - 무엇을 계기로 이 기능이 실행되는가?
    - 예: 메뉴에서 `1`을 입력 → “단어 추가” 기능 시작
2. 입력(Input)
    - 이 기능을 위해 필요한 정보가 무엇인지 정리
    - 예: 영어 단어, 한국어 뜻
3. 검증(Validation)
    - 입력이 말이 되는지 검사
    - 예: 비어 있지 않은지, 숫자가 맞는지, 범위 안에 들어오는지…
4. 핵심 처리(Core Logic)
    - 실제로 해야 하는 일
    - 예: 단어장이 이미 갖고 있는지 확인 → 없으면 추가
5. 출력(Output)
    - 결과를 사용자에게 어떻게 알려줄지
    - 예: “추가되었습니다”, “이미 있는 단어입니다” 메시지

---
`3.` 이걸 의사코드로 쓰면 어떻게 생기냐면?

예를 들어, “단어 추가” 기능 파이프라인 의사코드:
```
[트리거]
  사용자가 메뉴에서 1번을 선택하면 단어 추가 기능 실행

[입력]
  영어 단어 입력 받기
  한국어 뜻 입력 받기

[검증]
  만약 영어 또는 한국어가 비어 있으면:
      "둘 다 입력해야 합니다" 출력
      기능 종료

[핵심 처리]
  단어장 안에 이미 같은 영어 단어가 있는지 확인
  만약 이미 있으면:
      "이미 등록된 단어입니다" 출력
  아니면:
      단어장에 새 Word 객체 추가

[출력]
  성공이면 "추가되었습니다" 출력
```

이걸 코드로 바꾼 게 지금의 `handle_add_word()`죠
```python
def handle_add_word(vocab_book: VocabBook) -> None:
    print("\\n[ 단어 추가 ]")
    eng = input("영어 단어를 입력하세요: ").strip()
    kor = input("한국어 뜻을 입력하세요: ").strip()

    if not eng or not kor:  # ← [검증]
        print(" 단어와 뜻을 모두 입력해야 합니다.")
        return

    success = vocab_book.add_word(eng, kor)  # ← [핵심 처리]

    if success:
        print(f" '{eng} - {kor}' 단어가 추가되었습니다.")  # ← [출력]
    else:
        print(f" '{eng}' 단어는 이미 등록되어 있습니다.")  # ← [출력]
```

---
`4.` 전체 프로그램 흐름 의사코드는 이렇게

이제 프로그램 전체를 파이프라인처럼 보면
```
프로그램 시작
    단어장 생성 (기본 단어 몇 개 채우기)

    무한 반복:
        제목 출력
        메뉴 출력
        메뉴 번호 입력 받기

        만약 "1" 이면:
            단어 추가 기능 실행

        만약 "2" 이면:
            단어 목록 보기 기능 실행

        만약 "3" 이면:
            퀴즈 기능 실행

        만약 "0" 이면:
            "종료합니다" 출력
            반복문 탈출 → 프로그램 끝

        그 외 다른 값이면:
            "잘못된 입력" 메시지 출력
```

이게 그대로 `main()`이에요 👇
```python
def main() -> None:
    vocab_book = create_default_vocab_book()

    while True:
        print_title()
        print_menu()
        choice = input("메뉴를 선택하세요: ").strip()

        if choice == "1":
            handle_add_word(vocab_book)
            wait_for_enter()
        elif choice == "2":
            handle_show_words(vocab_book)
            wait_for_enter()
        elif choice == "3":
            handle_quiz(vocab_book)
            wait_for_enter()
        elif choice == "0":
            print("프로그램을 종료합니다. 👋")
            break
        else:
            print("⚠️ 잘못된 입력입니다. 0~3 사이의 숫자를 입력하세요.")
            wait_for_enter()
```

---
`5.` 그럼 “항상” 이렇게 쪼개야 할까? (좋은 패턴 정리)
	처음 개념을 잡을때, 오류를 줄이고, 흐름을 명확하게 잡으려면 이 패턴을 습관처럼 쓰면 좋습니다.

✅ 패턴 1: 세 가지로 나눠서 생각하기
1. 데이터(모델)
    - 지금 프로그램이 다루는 “명사”는 무엇인가?
    - 예: Word, VocabBook, User, Todo, Order…
2. 기능(서비스/로직)
    - 이 데이터로 어떤 “동사”를 할 건가?
    - 예: add_word, list_words, create_order, cancel_order…
3. 흐름(컨트롤러/진행 순서)
    - 언제 어떤 기능을 호출할 건가?
    - 예: 메뉴, 버튼 클릭, API 요청, 이벤트 등

지금 우리가 한 게 정확히 이거예요:
- 데이터 → `Word`, `VocabBook`
- 기능 → `add_word`, `get_quiz_list`, `check_answer`
- 흐름 → `main`, `handle_*`, `while`, `if`

---
✅ 패턴 2: 기능별 “의사코드 → 실제 코드” 순서
	새 기능을 추가하고 싶을 때, 이렇게 해보세요:

1. 먼저 의사코드로 한글로 적기
    - 종이에 적어도 좋고, 주석으로 적어도 좋고:
```
[기능 이름: 단어 삭제]
1) 삭제할 영어 단어를 입력 받는다
2) 단어장 안에서 그 단어를 찾는다
3) 없으면 "없다" 출력
4) 있으면 리스트에서 제거
5) "삭제 완료" 출력
```
    
2. 그 다음에 함수 틀부터 만들기
```python
 defhandle_delete_word(vocab_book: VocabBook) ->None:
  # 1) 삭제할 영어 단어 입력
  # 2) 단어 찾고
  # 3) 없으면 메시지
  # 4) 있으면 삭제
  # 5) 결과 출력
 ...
```
    
3. 그 안을 한 줄씩 채워 넣기
    - 이때, 의사코드를 거의 그대로 주석으로 쓰고,
    - 그 아래에 코드 한 줄씩 붙이는 스타일이 좋아요.
---
`6.` 오류 없이 코딩하는 가장 현실적인 방법

진짜 솔직히 말하면:
	오류 없이 처음부터 끝까지 짜는 건, 실무 10년차도 힘들어요.
	목표는 오류를 안 만드는 것이 아니라
	작게 만들고, 빨리 찾고, 빨리 고치는 것 입니다.

초보자에게 특히 좋은 습관은:
1. 기능을 너무 크게 잡지 않기
    - 단어장 프로그램 전부 X
    - 단어 1개 추가만 먼저 O
2. 조각 단위로 실행해 보기
    - `vocab_models.py` 에서 `create_default_vocab_book()`만 테스트
    - `print_all_words()` 같은 함수 하나 만들고 출력해보기
3. 의사코드 + 주석 먼저 작성 후, 코드 채우기
    - 빈 함수 만들고, 먼저 주석으로 “해야 할 일” 적기
    - 그 다음 실제 코드 한 줄씩 작성
4. 입력과 조건문 부분 특히 조심
    - `input()` 받은 값은 무조건 문자열
    - 숫자 필요하면 `isdigit()` 체크 → `int()` 변환
5. 실행을 자주 해보기
    - 50줄 짜고 실행 X
    - 5줄, 10줄만 짜고 바로 실행해 보기 O

---
`7.` 한 번 써볼 수 있는 “기능 설계 템플릿”

학생들이 쓰기 좋게, 기능 설계 템플릿을 드리면
```
[기능 이름] ____________________________

1. 이 기능의 목적:
   - (예: 단어장에 새 단어를 등록한다)

2. 이 기능이 다루는 데이터:
   - (예: 단어장(VocabBook), Word)

3. 입력:
   - (예: 영어 단어, 한국어 뜻)

4. 출력/결과:
   - (예: 성공/실패 메시지, 단어장에 실제로 추가됨)

5. 기본 흐름(의사코드):
   1)
   2)
   3)
   4)
   5)

6. 예외/에러 상황:
   - (예: 입력이 비어 있음, 이미 등록된 단어)
   - 이런 경우 어떻게 처리할지? → 메시지?
```

그 다음에 이걸 그대로 옮기면
```python
defhandle_xxx(...):
# 1)
# 2)
# 3)
# ...
pass
```
이런 느낌으로 자연스럽게 이어질 거예요.

---
`8.` 정리 한 줄로만 말하면…
	프로그램을 짤 때 항상 필요한 건
	데이터(명사), 기능(동사), 흐름(순서) 이고,
	기능 하나마다 트리거 → 입력 → 검증 → 처리 → 출력 파이프라인으로
	의사코드부터 써보는 습관이 “오류를 줄이는 최고의 패턴”이다.

---
좋은 프롬프트 구조 템플릿
	다음 템플릿을 쓰면 대부분의 문제에서 최고 효율이 나옵니다

1️⃣ 목적
	이 기능이 무엇을 해결하는지 한 줄

2️⃣ 데이터
어떤 객체/자료형을 사용할지
	

3️⃣ 기능 의사코드
```
1)
2)
3)
4)
5)
```

4️⃣ 제약 조건
- 기존 스타일 유지
- 함수/클래스 이름 유지
- 특정 파일/함수 안에서만 수정
- 예외 처리 포함

더 나아가기: AI를 “페어 프로그래머”처럼 쓰는 방법

🔁 1단계 — 먼저 의사코드만 만들라고 시키기
	이 기능을 위한 의사코드를 먼저 작성해줘.  
	코드 말고 — 흐름만 설명해.

✔ 의사코드를 검토 → 수정

---
💻 2단계 — 의사코드 기준으로 코드 생성 요청
	이제 이 의사코드를 기준으로 우리 프로그램 구조에 맞춰 코드 작성해줘.

---
🧪 3단계 — 테스트 + 수정 요청
실행해보니 숫자 입력 시 오류가 나. 입력 검증 부분만 보완해줘.