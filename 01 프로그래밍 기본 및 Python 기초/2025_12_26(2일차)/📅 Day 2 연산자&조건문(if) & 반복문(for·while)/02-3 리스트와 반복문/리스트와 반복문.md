# 🔹 리스트 선언하고 요소에 접근하기
	리스트(list)는 여러 개의 값을 하나로 묶어서 저장할 수 있는 
	자료형입니다.  
	쉽게 말하면, 변수를 여러 개 한 번에 저장할 수 있는 상자예요.
	리스트는 [] 스퀘어 브라켓 안에 값들을, 로 구분해서 넣습니다.

📖 문법, 구문(syntax): 
``` python
리스트이름 = [값1, 값2, 값3, ...]
```

</> 예시코드: 리스트 만들기
```python
mixed_list = ["사과", 10, "바나나", 20, "포도", 30]
print(mixed_list)
```

🖨️ 출력 결과:
```python
['사과', 10, '바나나', 20, '포도', 30]
```
---
◽ 리스트의 요소를 변경하는 기본 문법과 예시

📖 문법, 구문(syntax): 
```python
리스트[인덱스] = 새로운값
```
- 리스트는 mutable(변경 가능) 자료형이기 때문에, 인덱스를 통해 값을 직접 바꿀 수 있습니다.   ==-> 뮤터블==
- 
</> 예시코드: 숫자 리스트의 요소 변경
```python
numbers = [10, 20, 30]
numbers[1] = 99  # 인덱스 1에 해당하는 20을 99로 변경
print(numbers)
```

🖨️ 출력 결과:
```python
[10, 99, 30]
```

</> 예시코드: 문자열 리스트의 요소 변경
```python
fruits = ["apple", "banana", "cherry"]
fruits[0] = "grape"  # 첫 번째 요소 변경
print(fruits)
```

🖨️ 출력 결과:
```python
['grape', 'banana', 'cherry']
```
---
◽ 리스트 안에 튜플이 있는 경우 (튜플 전체 교체)
	튜플(tuple)은 "수정이 불가능한(immutable) 자료형"입니다.  ==-> 이뮤터블==

</> 예시코드: 리스트에 튜플이 담긴 구조
```python
data = [("Tom", 25), ("Lucy", 30)]
```
- `data`는 리스트입니다 → 수정 가능 (mutable)
- `("Tom", 25)`는 튜플입니다 → 수정 불가능 (immutable)

❌ 튜플 자체를 수정하려 하면 에러가 납니다
```python
data = [("Tom", 25), ("Lucy", 30)]
data[0][1] = 26
```

⚠️ 오류:
```python
TypeError: 'tuple' object does not support item assignment
```

하지만 리스트의 요소(튜플 전체)를 통째로 바꾸는 건 가능
```python
data = [("Tom", 25), ("Lucy", 30)]

data[0] = ("Tom", 26)  # 첫 번째 튜플 전체를 새 튜플로 교체
print(data)
```

🖨️ 출력 결과:
```python
[('Tom', 26), ('Lucy', 30)]
```
---
</> 예시코드: 리스트에서 요소에 접근하기 (인덱스 사용)
```python
print(fruits[0])  # 첫 번째 요소 
print(fruits[1])  # 두 번째 요소 
print(fruits[2])  # 세 번째 요소
```

🖨️ 출력 결과:
```python
apple banana cherry
```

🔍 해설:
- 리스트는 0부터 번호(index)가 시작돼요!
- `fruits[0]` → 리스트의 첫 번째 요소
- `fruits[2]` → 리스트의 세 번째 요소
- 순서대로 꺼내 쓸 수 있어서 정렬된 데이터 다룰 때 매우 유용
---
#####  ◽ 리스트에서의 IndexError 예외
	IndexError는 리스트에서 없는 위치(index)를 꺼내려고 할 때 발생하는 
	에러(오류)입니다.  
	리스트는 0부터 시작하는 순서(index)를 가지고 있고, 존재하지 않는 
	인덱스를 접근하면 오류가 납니다.
	예를 들어, 3개짜리 리스트에서 4번째 요소를 꺼내면 IndexError 발생!

</> 예시코드:  IndexError 발생 예
``` python
fruits = ["apple", "banana"]
print(fruits[3])  # ❌ IndexError 발생
```

🖨️ 출력 결과:
```python
IndexError: list index out of range
```

🔍 해설:
- `nums`는 총 3개 요소 → 인덱스는 `0`, `1`, `2`까지만 있어요.
- `nums[3]`은 존재하지 않는 네 번째 요소를 꺼내려고 해서 오류 발생
- 에러 메시지: `"리스트 인덱스가 범위를 벗어났습니다"`
---
# 🔹 튜플
	튜플은 수정이 안 되는(immutable) 자료형이지만, 그래서 오히려 특정 
	상황에서 더 유용하게 쓰입니다. 한 번 생성하면 내부 값을 변경할 수 
	없는(immutable) 구조입니다. 
==-> 이뮤터블==

```python
example = ("apple", 3, True)
```

◽ 튜플의 특징:
✅ 변경 불가능하여 안전함: 실수로 값을 수정할 위험이 없음
✅ 딕셔너리 키로 사용 가능: 리스트는 안 되지만, 튜플은 가능
```python
# 리스트를 딕셔너리의 키로 사용하면 오류 발생
my_dict = {
    [1, 2, 3]: "리스트를 키로"  # ❌ 오류
}

# 딕셔너리의 키로 사용 가능
my_dict = {
    (1, 2, 3): "튜플을 키로",
    ("Tom", 25): "사용자 정보 키"
}

print(my_dict[(1, 2, 3)])       # 출력: 튜플을 키로
print(my_dict[("Tom", 25)])     # 출력: 사용자 정보 키
```

🖨️ 출력 결과:
```python
튜플을 키로
사용자 정보 키
```

✅ 속도와 메모리 효율성 우수:	리스트보다 처리 속도가 빠르고 가볍다
✅ 데이터 그룹화 용이:	관련 데이터를 묶어서 하나처럼 다룰 수 있음 
    (예: 좌표, 사용자 정보 등)
```python
# 좌표 기반 정보 저장
locations = {
    (37.5665, 126.9780): "서울 시청",
    (35.1796, 129.0756): "부산 시청"
}

print(locations[(37.5665, 126.9780)])  # 출력: 서울 시청
```

---
# 🔹 리스트 연산자: 연결(+), 반복( ), len( )
	리스트는 숫자처럼 연산자(+, * )를 사용할 수 있는 자료형이에요.  
	또한 len() 함수를 사용하면 리스트에 몇 개의 값이 들어있는지도 
	알 수 있어요. 이 세 가지는 리스트를 다룰 때 가장 기본적인 
	도구입니다.

###### ◽ 주요 연산
| 연산      | 의미            | 예시                                 |
| ------- | ------------- | ---------------------------------- |
| `+`     | 리스트 연결        | `[1, 2] + [3, 4]` → `[1, 2, 3, 4]` |
| `*`     | 리스트 반복        | `[0] * 5` → `[0, 0, 0, 0, 0]`      |
| `len()` | 리스트 길이(요소 개수) | `len([10, 20, 30])` → `3`          |

</> 예시코드: 리스트 연결 (+)
``` python
a = [1, 2]
b = [3, 4]
result = a + b
print(result)
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4]
```

🔍 해설:
- 리스트끼리 `+`를 하면 두 리스트가 합쳐짐
- 단, 숫자처럼 덧셈이 아니라 리스트 연결의 의미임

</> 예시코드: 중첩 리스트 연결 + 연산 순서 주의
```python
a = [1, [2, 3]]
b = [[4, 5], 6]

result = a + b
print(result)
```

🖨️ 출력 결과:
```python
[1, [2, 3], [4, 5], 6]
```

🔍 해설:
- 리스트 `a`와 `b`는 둘 다 중첩 리스트(리스트 안에 리스트)를 포함하고 있음
- `+` 연산자는 리스트의 구조 자체는 변형하지 않고 단순히 이어 붙임
- `[2, 3]`과 `[4, 5]`는 각각 하나의 요소(리스트)로 취급됨
- 따라서 중첩된 구조도 그대로 유지됨

---
###### </> 예시코드: 리스트 반복 ( ) 얕은복사
```python
items = ["apple"] * 3 
print(items)
```

🖨️ 출력 결과:
```python
['apple', 'apple', 'apple']
```

🔍 해설:
- `"apple"`이 3번 반복된 리스트가 만들어짐
- `*`는 리스트를 여러 번 복제할 때 사용돼요

</> 예시코드: 중첩 리스트 반복의 주의점 (얕은 복사)
```python
items = [[0]] * 3
items[0][0] = 100
print(items)
```

🖨️ 출력 결과:
```python
[[100], [100], [100]]
```

🔍 해설:
- `[[0]] * 3`은 `[ [0], [0], [0] ]`처럼 보이지만, 같은 리스트 객체를 3번 복사한 것이에요.
- 그래서 `items[0][0] = 100`으로 바꾸면, 모든 하위 리스트가 함께 바뀌어요.   
- 이것을 얕은 복사(shallow copy)라고 합니다.

◽ 내부처리동작
`items = [[0]] * 3` 
- `[[0]]`는 먼저 `[0]`이라는 리스트 하나를 만듭니다.
- `* 3`은 그 하나의 리스트 객체를 3번 복사하는 게 아니라 "3번 참조"하는 것입니다.
- 즉, 구조는 이렇게 됩니다:
```python
items = [same_list, same_list, same_list]
```
- 각각의 `same_list`는 모두 같은 주소를 가진 `[0]`을 가리켜요.
- 그래서 다음 코드:
```python
items[0][0] = 100
```
이렇게 하면 어떤 일이 일어날까요?
- `items[0]`는 `[0]`이고, 그 안의 `[0][0]`은 `0`입니다.
- 여기에 `100`을 할당하면, 그 주소에 있는 값이 100으로 바뀜
- 그런데 `items[1]`, `items[2]`도 같은 리스트를 가리키고 있으므로 → 같이 바뀜!

```python
items = [[0]] * 3

print(id(items[0]))
print(id(items[1]))
print(id(items[2]))
```

🖨️ 출력 결과:
```
140711368540416  
140711368540416  
140711368540416  
```

🧐 처음 보기엔 이렇게 생각할 수 있어요:
```python
items = [[0]] * 3
```
이 코드를 보면:
	“리스트 `[0]`이 세 번 반복되니까 결과가 `[ [0], [0], [0] ]`처럼 서로 다른 리스트3개가 생기겠지?”  라고 생각하기 쉽습니다.

하지만 실제로는 그렇지 않아요!
	이 코드는 리스트 `[0]`을 하나만 만든 다음에,  
	그 하나의 리스트를 3번 복사하는 게 아니라, 3번 가리키는(참조하는) 방식입니다.
즉, 리스트 하나를 만들어 놓고  3번 똑같이 가리키는 리스트가 되는 거예요.

그래서 다음과 같이 코드를 작성하면:
```python
items[0][0] = 100
```
- 첫 번째 리스트의 값을 `100`으로 바꾼 건데,
- 실제로는 나머지 두 리스트도 같은 것을 가리키고 있기 때문에  
    → 전부 `100`으로 바뀌게 됩니다.

즉 위의 코드는 에러는 아니지만 개발자가 의도하지 않은 결과가 나올 수 있어서, '논리적인 오류' 또는 "함정(bug)"이라고 볼 수 있습니다.
```python
[[100], [0], [0]]  ← (기대했던 결과)
```
위와 같이 나오길 기대했을겁니다.

```python
# 의도한 바가 아니라면 이코드를 아래와 같이 수정하세요
items = [[0]] * 3

# 이렇게 수정합니다.
items = [[0], [0], [0]]
```

해결방법:
```python
items = []
items.append([0])
items.append([0])
items.append([0])

items[0][0] = 100
print(items)
```

---
📝 문제 1] 얕은 복사(shallow copy)
리스트 복사 후 수정해보기 다음 코드를 실행하면 어떤 결과가 출력될까요?
```python
a = [1, 2, 3]
b = a
b[0] = 99
print("a:", a)
print("b:", b)
```

🖨️ 출력 결과:
```python
a: [99, 2, 3]  
b: [99, 2, 3]
```

🔍 해설:
- `b = a`는 리스트를 복사한 게 아니라 같은 객체를 참조한 것
- 따라서 `b[0] = 99`로 값을 바꾸면, `a`도 함께 바뀐다
- 이것이 얕은 복사(shallow copy)의 대표적인 예

◽ a 데이터가 안바뀌게 하려면:
```python
a = [1, 2, 3]
b = a        # ❌ 얕은 복사 (같은 객체를 가리킴)
b[0] = 99
print("a:", a)  # ❌ a도 같이 바뀜 → a: [99, 2, 3]
print("b:", b)
```

</> 깊은 복사(deep copy) 슬라이싱 사용 (`[:]`)
```python
a = [1, 2, 3]
b = a[:]       # 새로운 리스트 복사
b[0] = 99
print("a:", a)  # a: [1, 2, 3]
print("b:", b)  # b: [99, 2, 3]
```

</> 깊은 복사(deep copy) list() 함수 사용
```python
a = [1, 2, 3]
b = list(a)     # 새 리스트 생성
b[0] = 99
print("a:", a)  # a: [1, 2, 3]
print("b:", b)  # b: [99, 2, 3]
```
---
📝 문제 2] 다음 코드를 실행했을 때 출력 결과는?
```python
a = [[1, 2], [3, 4]]
b = a * 2
b[0][0] = 100
print(a)
print(b)
```

🌟 힌트: `* 2`는 얕은 복사입니다. 내부 리스트는 그대로 공유됩니다.

✅ 정답 코드:
```python
[[100, 2], [3, 4]]
[[100, 2], [3, 4], [100, 2], [3, 4]]
```

🔍 해설:
- `a * 2`는 `a[0]`, `a[1]`를 복사하는 것이 아니라 그 리스트를 참조하는 새 리스트를 만듭니다.
- 따라서 `b[0][0] = 100`을 하면 `a[0][0]`도 함께 변경됩니다.

```python
a = [[1, 2], [3, 4]]

# 새로 복사된 리스트 b를 직접 만듭니다
b = []

# a의 첫 번째 줄을 복사해서 넣기
b.append([1, 2])

# a의 두 번째 줄을 복사해서 넣기
b.append([3, 4])

# 다시 한 번 같은 걸 복사해서 넣기
b.append([1, 2])
b.append([3, 4])

# b에서 첫 번째 줄의 첫 번째 숫자를 100으로 바꾸기
b[0][0] = 100

print(a)
print(b)
```


---
</> 예시코드:  리스트 길이 구하기 (len)
```python
fruits = ["banana", "mango", "peach"] 
print(len(fruits))
```

🖨️ 출력 결과:
```python
3
```

🔍 해설:
- `len()` 함수는 리스트에 몇 개의 요소가 있는지 알려줌
- 보통 반복문을 돌릴 때, 조건 검사할 때 많이 사용함

</> 예시코드: 중첩 리스트에서 `len()` 함수 사용하기
```python
classroom = [
    ["Alice", "Bob"],
    ["Charlie"],
    ["David", "Eve", "Frank"]
]

print(len(classroom))          # 전체 반의 수
print(len(classroom[2]))       # 세 번째 반의 학생 수
```

🖨️ 출력 결과:
```python
3
3
```

🔍 해설:
- `classroom`은 리스트 안에 리스트가 들어 있는 구조(중첩 리스트)입니다.
- `len(classroom)`은 전체 반(리스트)의 개수 → 3개
- `len(classroom[2])`는 세 번째 반에 있는 학생 이름의 개수 → 3명

---
📝 문제 1] 아래 코드에서 `IndexError`가 발생하지 않도록 수정하고, 마지막 요소를 출력하세요.
```python
fruits = ["apple", "banana", "cherry"]
print(fruits[ len(fruits) ])
```

🖨️ 출력 결과:
```python
cherry
```

✅ 정답 코드:
```python
print(fruits[ len(fruits) - 1 ])  # 마지막 요소 접근
```

🔍 해설:
- `len(fruits)`에서 반환되는 값은 3입니다. 그러나 인덱스 `3`은 존재하지 않음 (`IndexError`)
- 리스트의 인덱스는 `0 ~ len(fruits) - 1` 이므로, `-1`을 빼줘야 마지막 요소에 접근 가능
---
📝 문제 2] 당신은 색깔 목록에서 사용자가 선택한 인덱스 번호에 따라 색상을 보여주는 프로그램을 만들고 있습니다.  
리스트에는 아래와 같은 색상이 저장되어 있습니다.
```python
colors = ["red", "green", "blue", "yellow"]
```
사용자에게 0부터 3 사이의 숫자를 입력받아 해당 색상을 출력하려고 합니다.  
단, 사용자가 0~3 이외의 숫자를 입력하면 `"존재하지 않는 인덱스입니다."` 라고 출력해야 합니다.  
IndexError가 발생하지 않도록 조건문을 사용하여 해결하세요.

🖨️ 출력 예시 1 (예시 입력: `2`):
```python
선택한 색상: blue
```

🖨️ 출력 예시 2 (예시 입력: 5):
```python
존재하지 않는 인덱스입니다.
```

✅ 정답 코드:
```python
colors = ["red", "green", "blue", "yellow"]
i = int(input("색상 번호를 입력하세요 (0~3): "))

if 0 <= i < len(colors):
    print("선택한 색상:", colors[i])
else:
    print("존재하지 않는 인덱스입니다.")
```

🔍 해설:
- `len(colors)`는 4이므로 유효한 인덱스는 `0`, `1`, `2`, `3`
- 조건문 `0 <= i < len(colors)`를 사용하면,  
    존재하지 않는 인덱스를 미리 걸러낼 수 있어 `IndexError`를 방지할 수 있습니다.
---
📝 문제 3] 리스트의 인덱스를 음수를 사용하여 300이 출력되게 프린트 함수를 완성하세요.
```python
nums = [100, 200, 300, 400]
print()
```

✅ 정답 코드:
```python
nums = [100, 200, 300, 400]
print(nums[-2])
```

🔍 해설:
- 파이썬 리스트는 음수 인덱스도 허용함
- `-1`은 마지막 요소, `-2`는 뒤에서 두 번째 요소  
    → `nums[-2]`는 `300`
---
📝 문제 4] 리스트 내부에 있는 문자열 각각의 인덱스를 이용해, 모든 단어의 첫 글자만 출력하세요.
```python
words = ["python", "list", "index", "error"]
```

🖨️ 출력 결과:
```python
p
l
i
e
```

✅ 정답 코드:
```python
words = ["python", "list", "index", "error"]

if len(words) > 0:
    print(words[0][0])  # p

if len(words) > 1:
    print(words[1][0])  # l

if len(words) > 2:
    print(words[2][0])  # i

if len(words) > 3:
    print(words[3][0])  # e
```
---
# 🔹 리스트 요소 추가: append( ), insert( )
	리스트 요소 추가는 리스트에 새로운 값을 넣는 방법입니다.  
	대표적으로 append()와 insert() 메서드를 사용합니다.

| 메서드            | 기능 설명                  |
| -------------- | ---------------------- |
| `append(x)`    | 리스트 맨 뒤에 x 추가          |
| `insert(i, x)` | i번째 위치에 x 삽입 (기존 값 밀림) |

◽ append( ) 함수
	`append()`는 리스트의 마지막에 새로운 요소를 추가할때 사용합니다. 
	형식: `리스트.append(요소)`

</> 예시코드: `append()`로 맨 끝에 요소 추가하기
``` python
numbers = [1, 2, 3]
numbers.append(4)
print(numbers)
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4]
```

🔍 해설:
- 여러 개를 한 번에 추가하려면 `append([4, 5])`가 아닌 `extend()`나 `+` 연산이 필요하지만,  여기서는 하나씩 추가하는 방식을 배웁니다.
---
◽ insert( ) 함수
	리스트의 특정 위치(인덱스)에 새로운 요소를 삽입할 때 사용합니다.
	형식: `리스트.insert(인덱스, 요소)`

</> 예시코드: `insert()`로 원하는 위치에 삽입하기
```python
fruits = ["apple", "banana", "grape"] 
fruits.insert(1, "orange") 
print(fruits)
```

🖨️ 출력 결과:
```python
['apple', 'orange', 'banana', 'grape']
```

🔍 해설:
- `insert(1, "orange")`는 `"orange"`를 index 1 위치에 삽입
- 기존의 `"banana"`는 뒤로 밀려나서 `2번째` 위치가 됨
---
##### ◽ 리스트 연결 연산자와 요소 추가의 차이
	리스트에 새로운 값을 넣는 방법은 여러 가지가 있습니다. 
	그중 자주 혼동되는 것이 바로
	- append() 메서드
	- 리스트 연결 연산자 +
	두 방법 모두 리스트에 값을 추가할 수 있지만, 동작 방식은 매우 
	다릅니다.

</> 예시코드: `append()`는 리스트 안에 리스트를 통째로 넣음
```python
a = [1, 2] 
a.append([3, 4]) 
print(a)
```

🖨️ 출력 결과:
```python
[1, 2, [3, 4]]
```

🔍 해설:
- `append()`는 전체를 하나의 요소로 추가
- 즉, `[3, 4]`라는 리스트 그 자체가 한 칸으로 들어감
- 결과적으로 리스트 안에 리스트(중첩 리스트)가 생김

---
</> 예시코드: `+` 연산자는 두 리스트를 연결해서 새 리스트로 만듦
```python
b = [1, 2] 
b = b + [3, 4] 
print(b)
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4]
```

🔍 해설:
- `+` 연산은 두 리스트를 이어 붙이는 것
- 결과는 새로운 리스트 → 원래 있던 리스트는 변하지 않고 새로운 리스트로 대체
- `[3, 4]`가 하나의 요소가 아니라, 개별 요소로 들어감

---
📝 문제1] 당신은 할 일 목록을 리스트로 만들고 있습니다.  
먼저 `["공부하기", "청소하기"]`라는 리스트가 있고,  여기에 `"운동하기"`라는 항목을 리스트의 마지막에 추가하려고 합니다.  어떤 함수를 사용해야 할까요? 
해당 코드를 작성하고 결과를 출력하세요.
```python
todo = ["공부하기", "청소하기"]
```

🖨️ 출력 결과:
```python
['공부하기', '청소하기', '운동하기']
```

✅ 정답:
```python
todo = ["공부하기", "청소하기"]
todo.append("운동하기")
print(todo)
```

🔍 해설:
-  `append()`는 리스트 끝에 요소 하나를 추가할 때 사용
- 기존 요소들은 그대로 있고, `"운동하기"`가 마지막에 붙음

---
📝 문제2] 도서 목록 `["책A", "책B", "책C"]`가 있을 때,  가장 앞에 `"신간도서"`를 삽입해서 우선순위를 높이려고 합니다.  어떻게 해야 `"신간도서"`가 가장 앞에 오게 될까요?
```python
books = ["책A", "책B", "책C"]
```

🖨️ 출력 결과:
```python
['신간도서', '책A', '책B', '책C']
```

✅ 정답 코드:
```python
books = ["책A", "책B", "책C"]
books.insert(0, "신간도서")
print(books)
```

🔍 해설:
- `insert(0, ...)`은 리스트의 0번째 자리에 삽입한다는 의미
- 나머지 요소들은 자동으로 한 칸씩 뒤로 밀림
---
📝 문제3] 다음 코드에서 `append()`와 `+` 연산자를 사용한 결과는 어떻게 다를까요?  코드를 실행한 후 `nums1`과 `nums2`의 결과를 비교해보세요.
```python
nums1 = [1, 2]
nums1.append([3, 4])

nums2 = [1, 2]
nums2 = nums2 + [3, 4]
```

✅ 정답 코드:
```python
nums1 = [1, 2]
nums1.append([3, 4])

nums2 = [1, 2]
nums2 = nums2 + [3, 4]

print("append 결과:", nums1)
print("연결 연산자 결과:", nums2)
```

🖨️ 출력 결과:
```python
append 결과: [1, 2, [3, 4]]
연결 연산자 결과: [1, 2, 3, 4]
```

🔍 해설:
- `append([3, 4])`는 리스트 자체를 한 덩어리로 추가
- `+ [3, 4]`는 리스트를 풀어서 이어붙임
- 따라서 `append` 결과는 중첩 리스트가 되고, `+`는 낱개 요소가 추가됨
---
📝 문제4] 사용자에게 3개의 영화 제목을 입력받아, 입력한 순서대로 리스트에 `insert()`를 사용해 항상 맨 앞에 추가하려고 합니다.  
출력결과와 사용자 입력예시를 참고하여 코드를 작성하세요.

🖨️ 출력 결과:
```python
저장된 영화 목록: ['Terminator', 'Avatar', 'Titanic']
```

🖨️ 사용자 입력 예시:
```python
첫 번째 영화: Titanic  
두 번째 영화: Avatar  
세 번째 영화: Terminator
```

✅ 정답 코드:
```python
movies = []

movie1 = input("첫 번째 영화: ")
movies.insert(0, movie1) # 첫 번째 영화: Terminator

movie2 = input("두 번째 영화: ")
movies.insert(0, movie2) # 두 번째 영화: Avatar

movie3 = input("세 번째 영화: ")
movies.insert(0, movie3) # 세 번째 영화: Titanic

print("저장된 영화 목록:", movies)
```

🔍 해설:
- `insert(0, ...)`를 반복하면 새로운 입력이 항상 맨 앞에 쌓임
- 따라서 가장 마지막에 입력한 항목이 리스트의 맨 앞에 위치하게 됨
---
# 🔹 리스트 요소 제거하기
	리스트는 값을 추가하는 것뿐만 아니라, 필요 없는 값을 제거할 수도 
	있습니다.  
	예를 들어, 잘못 들어간 데이터를 빼거나, 사용한 값을 삭제하는 등  
	데이터를 유지보수하거나 정리할 때 꼭 필요한 기능이에요.

리스트에서 요소를 제거하는 방법은 여러 가지가 있는데,  
이번에는 인덱스를 기준으로 요소를 제거하는 방법을 알아보겠습니다.

##### ◽  `del` 키워드란?
	del은 파이썬의 삭제 전용 키워드로, 리스트에서 특정 위치(index)의 
	값을 제거할 때 사용합니다.

</> 예시코드:  del로 리스트 요소 삭제
```python
nums = [10, 20, 30, 40] 

del nums[1] 
print(nums)
```

🖨️ 출력 결과:
```python
[10, 30, 40]
```

🔍 해설:
- `nums[1]` 위치의 값인 `20`이 삭제됨 
- 삭제된 자리는 사라지고, 나머지 값들이 앞으로 당겨짐
- 리스트 자체가 바로 바뀜 (in-place)
   
---
##### ◽ `pop()` 메서드란?
	pop()은 리스트에서 특정 위치의 값을 꺼내서 삭제합니다.  
	삭제와 동시에 그 값을 반환(돌려줌)하는 기능이 있어요.
	
- 아무 것도 쓰지 않으면 마지막 요소를 제거
- `pop(index)`처럼 쓰면 해당 인덱스의 요소를 제거

</> 예시코드:  pop( )으로 마지막 요소 제거
```python
letters = ['a', 'b', 'c'] 
removed = letters.pop() 

print("삭제된 값:", removed) 
print("남은 리스트:", letters)
```

🖨️ 출력 결과:
```python
삭제된 값: c   
남은 리스트: ['a', 'b']
```

</> 예시코드:  pop(index)로 중간 요소 제거
```python
letters = ['a', 'b', 'c'] 
letters.pop(0) 
print(letters)
```

🖨️ 출력 결과:
```python
['b', 'c']
```

🔍 해설:
- `pop(0)` → 0번 인덱스의 `'a'`를 제거함
- `pop()`은 삭제한 값을 되돌려받을 수 있다는 점이 `del`과 차이점
---
##### ◽값으로 제거하기 : remove( )
	리스트에서 특정값 하나를 제거합니다. 가장먼저 나오는 값 하나만 제거됨

</> 예시코드:
```python
fruits = ["apple", "banana", "apple", "cherry"]
fruits.remove("apple")
print(fruits)
```

🖨️ 출력 결과:
```python
['banana', 'apple', 'cherry']
```

🔍 해설:
- `remove("apple")`은 리스트에서 첫 번째로 나오는 'apple'만 제거합니다.
- 나머지 `'apple'`은 그대로 유지됨.
- 만약 제거하려는 값이 리스트에 없으면 에러가 발생합니다.

---
##### ◽모두 제거하기: clear( )
	리스트 안의 모든 요소를 한 번에 제거합니다.  
	(리스트는 남고, 내용만 비워짐)

</> 예시코드:
```python
numbers = [1, 2, 3, 4]
numbers.clear()
print(numbers)
```

🖨️ 출력 결과:
```python
[]
```

🔍 해설:
- `clear()`는 리스트를 비우는 함수입니다.
- 리스트 객체는 그대로 있지만, 요소가 모두 삭제되어 빈 리스트가 됩니다.
- 나중에 다시 `append()`로 요소를 추가할 수 있습니다.
---
##### ◽ 리스트 간 빼기는 안 됨 ❌
```python
a = [1, 2, 3]
b = [2, 3]
print(a - b)
```

🛑 🖨️ 출력 결과:
```python
TypeError: unsupported operand type(s) for -: 'list' and 'list'
```

🔍 해설:
- 리스트끼리 `-` 연산은 안 됩니다
- 파이썬은 리스트 간 빼기를 직접 지원하지 않음
---
##### ◽ 리스트에서 값을 뺀 결과를 새로 만들기 (값 변경)
```python
a = [10, 20, 30]
b = [a[0] - 5, a[1] - 5, a[2] - 5]
print(b)
```

🖨️ 출력 결과:
```python
[5, 15, 25]
```

🔍 해설:
- 리스트 `a`의 각 요소에서 5씩 빼서 새로운 리스트 `b`를 만든 것

---
📝 문제1] 당신은 숫자 리스트 `[10, 20, 30, 40, 50]`에서  세 번째 값(`30`)을 인덱스를 이용해 삭제하려고 합니다.  
`del` 키워드를 사용해 코드를 작성하고, 최종 리스트를 출력해보세요.
```python
nums = [10, 20, 30, 40, 50]
```

🖨️ 출력 결과:
```python
[10, 20, 40, 50]
```

✅ 정답:
```python
nums = [10, 20, 30, 40, 50]
del nums[2]
print(nums)
```

🔍 해설:
- `del`은 인덱스로 삭제할 때 사용
- `nums[2]`는 `30`이므로 삭제되고, 나머지 값들이 앞으로 당겨짐

---
📝 문제2] 과일 리스트 `["apple", "banana", "cherry", "banana"]`에서  
처음 나오는 `"banana"` 하나만 삭제하려고 합니다.  값으로 삭제하는 방법을 사용하세요.

🖨️ 출력 결과:
```python
['apple', 'cherry', 'banana']
```

✅ 정답:
```python
fruits = ["apple", "banana", "cherry", "banana"]
fruits.remove("banana")
print(fruits)
```

🔍 해설:
-  `remove("banana")`는 처음 나타나는 `"banana"`만 삭제
- 나중에 나오는 `"banana"`는 그대로 남아 있음

---
📝 문제3] 다음 코드는 `pop()`을 사용하여 마지막 값을 꺼내고,  그 값을 따로 저장한 후 출력한 후  리스트도 출력해보세요.
리스트: `[100, 200, 300]`  
마지막 값을 꺼내고, 꺼낸 값과 리스트의 상태를 출력해보세요.
```python
scores = [100, 200, 300]
```

🖨️ 출력 결과:
```python
꺼낸 점수: 300
남은 점수: [100, 200]
```

✅ 정답:
```python
scores = [100, 200, 300]
last_score = scores.pop()
print("꺼낸 점수:", last_score)
print("남은 점수:", scores)
```

🔍 해설:
-  `pop()`은 삭제 + 반환
- 꺼낸 값을 따로 저장할 수 있어 이후에도 사용할 수 있음
---
📝 문제 4] 리스트에 여러 개의 데이터를 저장한 후,  모든 요소를 한꺼번에 비우고 싶습니다. `clear()` 함수를 사용해 리스트를 완전히 초기화하세요.
```python
data = ["python", "java", "c++"]
```

🖨️ 출력 결과:
```python
초기화된 리스트: []
```

✅ 정답:
```python
data = ["python", "java", "c++"]
data.clear()
print("초기화된 리스트:", data)
```

🔍 해설:
- `clear()`는 리스트를 완전히 비움
- 리스트 객체는 그대로 있고, 요소만 없어져 빈 리스트가 됨

---
# 🔹 리스트 정렬하기: sort( )
	리스트에 들어 있는 숫자나 글자들을 순서대로 정렬하고 싶을 때  
	파이썬에서는 sort() 메서드를 사용합니다.
	sort()는 리스트를 오름차순(작은 값 → 큰 값)으로 정렬하며,  
	원한다면 내림차순(큰 값 → 작은 값)으로도 바꿀 수 있어요.
	sort()는 리스트 안에 있는 값들의 순서를 정리해주는 도구입니다.

📖 문법, 구문(syntax)
```python
리스트.sort()  # 오름차순 정렬
리스트.sort(reverse=True) # 내림차순 정렬
```

###### ◽ 정렬 순서 
| 종류  | 예시 문자       | 유니코드 순서     | 정렬 위치 |
| --- | ----------- | ----------- | ----- |
| 숫자  | `'0'`~`'9'` | U+0030~0039 | 가장 앞  |
| 대문자 | `'A'`~`'Z'` | U+0041~005A | 그 다음  |
| 소문자 | `'a'`~`'z'` | U+0061~007A | 그 다음  |
| 한글  | `'가'`~      | U+AC00~     | 가장 뒤  |


---
</> 예시코드: 숫자 리스트 오름차순 정렬
```python
mixed = ["apple", "Apple", "가나다", "Banana", "banana", "123", "Zebra", "zoo", "가방", "100", "10"]
mixed.sort()
print(mixed)
```

🖨️ 출력 결과:
```python
['10', '100', '123', 'Apple', 'Banana', 'Zebra', 'apple', 'banana', 'zoo', '가나다', '가방']
```

🔍 해설:
- 숫자 문자열 `'10'`, `'100'`, `'123'` 가장 먼저 정렬됨 
- 대문자 문자열 `'Apple'`, `'Banana'`, `'Zebra'`
- 소문자 문자열 `'apple'`, `'banana'`, `'zoo'`
- 한글 문자열 `'가나다'`, `'가방'`
    가장 마지막에 정렬됨 (한글의 유니코드가 가장 크기 때문)
---
</> 예시코드: 내림차순 정렬
```python
mixed = ["apple", "Apple", "가나다", "Banana", "banana", "123", "Zebra", "zoo", "가방", "100", "10"]
mixed.sort(reverse=True)
print(mixed)
```

🖨️ 출력 결과:
```python
['가방', '가나다', 'zoo', 'banana', 'apple', 'Zebra', 'Banana', 'Apple', '123', '100', '10']
```

🔍 해설:
- `reverse=True`를 주면 유니코드 순서의 역방향으로 정렬됩니다.
- 즉, 유니코드 값이 큰 것부터 작은 것 순서로 나열됩니다.

정렬 순서 (내림차순일 때):
1. 한글 → 유니코드 값이 가장 큼 → 제일 앞에 정렬
2. 소문자 (`zoo`, `banana`, `apple`)
3. 대문자 (`Zebra`, `Banana`, `Apple`)
4. 숫자 문자열 (`123`, `100`, `10`) → 유니코드상 가장 작으므로 마지막
---
###### ◽  `sort()` vs `sorted()`
| 함수 이름      | 원본 리스트 <br>변경 여부 | 반환값                | 사용 목적                          |
| ---------- | ---------------- | ------------------ | ------------------------------ |
| `sort()`   | 원본을 직접 변경        | None 변수에 <br>저장 불가 | 리스트 자체를 정렬하고 싶을 때              |
| `sorted()` | 원본은 그대로 유지       | 새로운 리스트 반환         | 원본은 그대로 두고 정렬 결과만 따로 저장하고 싶을 때 |

</> 차이를 보여주는 예시코드:
```python
original = ["banana", "Apple", "가나다", "123", "apple", "Zebra", "가방", "10"]
new_sorted = sorted(original)

print("원본 리스트:", original)
print("정렬된 새 리스트:", new_sorted)
```

🖨️ 출력 결과:
```python
원본 리스트: ['banana', 'Apple', '가나다', '123', 'apple', 'Zebra', '가방', '10']
정렬된 새 리스트: ['10', '123', 'Apple', 'Zebra', 'apple', 'banana', '가나다', '가방']
```

🔍 해설:
- `sorted(original)`은 원본을 변경하지 않음
    - `original`은 그대로 유지
- 정렬 기준은 유니코드 순서
    - `숫자 문자열` → `'10'`, `'123'`이 가장 앞
    - `대문자` → `'Apple'`, `'Zebra'`
    - `소문자` → `'apple'`, `'banana'`
    - `한글` → `'가나다'`, `'가방'`이 가장 뒤
- 새로 만들어진 리스트 `new_sorted`는 정렬된 결과를 담고 있음
---
###### ◽ `key` 매개변수란?
	정렬 함수(sorted(), sort())에서 정렬 기준을 내 마음대로 설정
	할 수 있게 해주는 옵션입니다.
	
특징:
- `sort()` 또는 `sorted()` 함수에서 사용하는 정렬 기준 함수
- 리스트의 각 요소에 이 함수를 먼저 적용한 결과값을 기준으로 정렬함
- 원본 값은 유지되며, 비교할 때만 해당 함수를 거쳐 비교함

📖 문법, 구문(syntax): 
```python
sorted(리스트, key=정렬기준함수)
```

###### ◽ 자주 쓰는 `key` 함수 예시
| `key` 값              | 설명                          | 예시 결과                        |
| -------------------- | --------------------------- | ---------------------------- |
| `key=str.lower`      | 모두 소문자로 변환해 비교 (대소문자 무시 정렬) | "apple", "Apple" 순서 통일       |
| `key=str.upper`      | 모두 대문자로 변환해 비교              | 대소문자 구분 없이 정렬                |
| `key=len`            | 요소의 길이를 기준으로 정렬             | 문자열 길이 순 정렬                  |
| `key=int`            | 숫자형 문자열을 숫자로 변환해 정렬         | `"10"`과 `"2"` 비교 시 `"2"`가 먼저 |
| `key=lambda x: x[1]` | 튜플의 두 번째 요소 기준으로 정렬         | `(a, 2)`의 `2` 기준 정렬          |

---
</> 예시코드: `key=str.lower` – 대소문자 구분 없이 정렬
```python
names = ["banana", "Apple", "cherry", "apple"]
names.sort(key=str.lower)
print(names)
```

🖨️ 출력 결과:
```python
['Apple', 'apple', 'banana', 'cherry']
```

🔍 해설:
- `str.lower`는 모든 값을 소문자로 변환해서 비교
- 하지만 출력 결과는 원래 대소문자 그대로 유지
- `'Apple'`과 `'apple'`은 비교 기준으로 같지만, 원래 순서대로 정렬됨
---
</> 예시코드: `key=len` – 길이 기준 정렬
```python
words = ["dog", "elephant", "cat", "tiger"]
words.sort(key=len)
print(words)
```

🖨️ 출력 결과:
```python
['dog', 'cat', 'tiger', 'elephant']
```

🔍 해설:
- 각 단어의 길이(`len`)를 기준으로 정렬
- 길이가 짧은 단어부터 긴 단어 순으로 나열됨
---
</> 예시코드:  `key=int` – 숫자 문자열을 실제 숫자처럼 정렬
```python
nums = ["10", "2", "30", "1"]
nums.sort(key=int)
print(nums)
```

🖨️ 출력 결과:
```python
['1', '2', '10', '30']
```

🔍 해설:
- 문자열이지만 `int`로 변환해서 숫자처럼 정렬
- 일반 문자열 정렬이면 `"10"`이 `"2"`보다 앞에 와야 하지만,  
    `int`를 쓰면 실제 숫자값 10과 2를 비교함
---
###### </> 예시코드: `key=lambda x: x[1]` – 튜플의 두 번째 값 기준 정렬
```python
students = [("민수", 85), ("영희", 95), ("철수", 90)]
students.sort(key=lambda x: x[1])
print(students)
```

🖨️ 출력 결과:
```python
[('민수', 85), ('철수', 90), ('영희', 95)]
```

🔍 해설:
- 각 튜플의 두 번째 값(점수)을 기준으로 오름차순 정렬
- `lambda x: x[1]`는 `요소x = ("민수", 85)`  `x[1] 값 = 85` 이 뜻으로 점수기준으로 정렬하겠다는 뜻입니다.
---
</> 예시코드: `ey=lambda x: x[::-1]` – 문자열을 뒤집은 값 기준 정렬
```python
words = ["abc", "xyz", "bca", "cab"]
words.sort(key=lambda x: x[::-1])
print(words)
```

🖨️ 출력 결과:
```python
['cab', 'bca', 'abc', 'xyz']
```
---
◽ 순차적으로 단계처리과정
✅ 1단계: 각 요소를 거꾸로 만들기
```python
words = ["abc", "xyz", "bca", "cab"]

"abc" -> "cba"
"xyz" -> "zyx"
"bca" -> "acb"
"cab" -> "bac"
```

✅ 2단계:  뒤집은 값을 기준으로 알파벳 오름차순 정렬
```python
"abc" -> "bca"
"bca" -> "cab"
"cab" -> "abc"
"xyz" -> "xyz"

# 정렬기준 
"acb" < "bac" < "cba" < "zyx"
```

✅ 3단계: 최종결과
```python
["bca", "cab", "abc", "xyz"]
```

🔍 해설:
- 리스트 words를 정렬하되 각 단어를 거꾸로 뒤집은 값을 기준으로 정렬됩니다.
- 1차 원래단어를 뒤집고
- 2차 뒤집힌 값들을 알파벳 순으로 정렬합니다.
- `lambda x: x[::-1]`는 단어를 거꾸로 만드는 함수로 단어를 뒤집은 결과 기준으로 정렬됩니다.
- 그래서 단순히 `["abc", "bca", "cab", "xyz"]` 이렇게 정렬되지 않고 거꾸로 봤을때 순서대로 정렬됩니다.
---
###### ◽ 정렬 기준 1 : 문자열을 거꾸로
```python
lambda x: x[::-1]
```

- `"abc"[::-1]` → `"cba"`
- `"cat"[::-1]` → `"tac"`
즉, 문자열을 뒤에서부터 정렬하는 느낌입니다.

◽ 정렬 기준 2 : 문자열을 거꾸로
```python
lambda x: x[-1]
```

- `"abc"[-1]` → `"c"`
- `"cat"[-1]` → `"t"`
즉, 각 단어의 마지막 글자만 보고 정렬하는 기준입니다.

</>예시코드
```python
words = ["dog", "cat", "bat", "ant"]

# 기준 1: 문자열을 거꾸로 정렬
print(sorted(words, key=lambda x: x[::-1]))

# 기준 2: 마지막 글자 기준 정렬
print(sorted(words, key=lambda x: x[-1]))
```

✅ 정답 코드:
```python
words = ["dog", "cat", "bat", "ant"]

print("::-1 =",sorted(words, key=lambda x: x[::-1]))#문자열을 뒤집은 값을 기준으로 정렬
print("-1 =",sorted(words, key=lambda x: x[-1]))  # 문자열의 마지막 글자를 기준으로 정렬
```

🖨️ 출력 결과:
```python
::-1 = ['dog', 'bat', 'cat', 'ant']
-1 = ['dog', 'cat', 'bat', 'ant']
```
---
◽ `x[::-1]` → 문자열 뒤집기 기준
```python
words = ["dog", "cat", "bat", "ant"]

"dog" →	"god"
"cat" →	"tac"
"bat" →	"tab"
"ant" →	"tna"
```

◽ 이걸 알파벳 순으로 정렬하면:
```python
"god" → "dog"
"tab" → "bat"
"tac" → "cat"
"tna" → "ant"

# 결과
::-1 = ['dog', 'bat', 'cat', 'ant']
```
---
◽ `x[-1]` → 마지막 글자 기준
```python
words = ["dog", "cat", "bat", "ant"]

"dog" →	"g"
"cat" →	"t"
"bat" →	"t"
"ant" →	"t"

정렬기준: "g", "t", "t", "t"
정렬 순서: "dog" < "cat" < "bat" < "ant"
같은 기준값 ("t")을 가진 경우에는 리스트 안에서의 원래 순서를 유지합니다.
이것을 안정정렬(stable sort)라고 합니다.

# 결과
-1 = ['dog', 'cat', 'bat', 'ant']
```
---
📝 문제 1] 다음 리스트를 **문자열을 거꾸로 뒤집은 결과**를 기준으로 오름차순 정렬하세요.
```python
names = ["kim", "lee", "choi", "park"]
```

✅ 정답 코드:
```python
names = ["kim", "lee", "choi", "park"]
result = sorted(names, key=lambda x: x[::-1])
print(result)
```

🖨️ 출력 결과:
```python
['lee', 'choi', 'park', 'kim']
```

◽ 알파벳 뒤집기
```python
"lee"  → "eel"
"choi" → "iohc"
"park" → "krap"
"kim"  → "mik"
```

◽ 뒤집은 상태로 정렬
```python
"lee"  → "eel"
"choi" → "iohc"
"park" → "krap"
"kim"  → "mik"
```

◽ 정렬된 결과
```python
"eel" "iohc" "krap" "mik"
```

🖨️ 출력 결과: 정렬은 뒤집어서 하지만 출력은 원상태로
```python
['lee', 'choi', 'park', 'kim']
```
---
📝 문제 2] 다음 리스트를 단어의 마지막 글자를 기준으로 오름차순 정렬하세요.
```python
colors = ["blue", "green", "black", "white"]
```

✅ 정답 코드:
```python
colors = ["blue", "green", "black", "white"]
result = sorted(colors, key=lambda x: x[-1])
print(result)
```

```python
colors = ["blue", "green", "black", "white"]
"blue"   →  "e"
"green"  →  "n"
"black"  →  "k"
"white"  →  "e"

정렬기준: "e" "e" "k" "n"
정렬 순서: "blue" "white" "black" "green"  
```

🖨️ 출력 결과:
```python
['blue', 'white', 'black', 'green']
```
---
# 🔹 in / not in 연산자
	리스트 안에 특정 값이 들어있는지 확인하고 싶을 때, 파이썬에서는 
	in 연산자 또는 not in 연산자를 사용합니다.
	"값 in 리스트" → 값이 리스트 안에 있으면 True, 없으면 False  
	"값 not in 리스트" → 값이 리스트 안에 없으면 True

📖 문법, 구문(syntax): 
```python
값 in 리스트       # 값이 들어 있으면 True 
값 not in 리스트   # 값이 없으면 True
```

</> 예시코드: 값이 리스트에 있는 경우
```python
fruits = ["apple", "banana", "cherry"] 
print("banana" in fruits)
```

🖨️ 출력 결과:
```python
True
```

🔍 해설:
- `"banana"`는 리스트 `fruits` 안에 있으므로 `True` 반환
- 조건문에서 자주 사용됨 → `if "banana" in fruits:`
---
</> 예시코드:  값이 리스트에 없는 경우
```python
numbers = [1, 2, 3] 

print(5 in numbers) 
print(5 not in numbers)
```

🖨️ 출력 결과:
```python
False 
True
```

🔍 해설:
- `5`는 리스트 안에 없으므로 `in`은 `False`, `not in`은 `True`
---
</> 예시코드:  조건문과 함께 사용
```python
colors = ["red", "blue", "green"] 

if "green" in colors:     
	print("green이 포함되어 있어요!")
```

🖨️ 출력 결과:
```python
green이 포함되어 있어요!
```

🔍 해설:
- `"green"`이 리스트에 있는지 확인한 후 메시지 출력
- 이런 방식은 검색 기능, 필터링, 중복 확인 등에 활용 가능
---
📝 문제1] 사용자에게 동물 이름을 입력받아, 리스트에 있는지 검사한 후 결과를 출력하세요.

단, 입력값의 대소문자는 구분하지 않고 비교하세요.
```python
animals = ["cat", "dog", "bird", "rabbit"] 
```

🖨️ 출력 결과:
```python
리스트에 있습니다!
```

✅ 정답 코드:
```python
animals = ["cat", "dog", "bird", "rabbit"]
word = input("동물 이름을 입력하세요: ")

if word.lower() in animals:
    print("리스트에 있습니다!")
else:
    print("리스트에 없습니다.")
```

🔍 해설:
	사용자의 입력값이 `"Dog"`처럼 대문자를 포함하더라도, `lower()`로 소문자로 바꿔 비교하면 리스트 안의 `"dog"`과 일치 가능

---
📝 문제2] 리스트 `["red", "blue"]`에 `"green"`이 없을 때만 `"green 없음"`을 출력해보세요.

🖨️ 출력 결과:
```python
green 없음
```

✅ 정답 코드:
```python
colors = ["red", "blue"]  

if "green" not in colors:     
	print("green 없음")
```

🔍 해설:
- `"green"`은 리스트에 없기 때문에 `not in` 조건이 `True`가 되어 출력됨
---
📝 문제3] 다음은 금지어가 있는 단어 리스트입니다.
사용자가 입력한 단어가 금지어 리스트에 없을 경우에만 `"사용 가능"`을 출력하세요.

🖨️ 출력 결과(입력: hello):
```python
사용 가능
```

✅ 정답 코드:
```python
banned_words = ["badword", "uglyword", "hate"]
word = input("사용할 단어를 입력하세요: ")

if word not in banned_words:
    print("사용 가능")
else:
    print("금지된 단어입니다.")
```

🔍 해설:
- `not in` 연산자를 통해 금지 리스트에 포함되지 않으면 `"사용 가능"` 판단
---
# 🔹 for 반복문
	for 반복문은 리스트처럼 여러 개의 값이 들어 있는 자료형을 하나씩 
	꺼내서 사용할 때 사용하는 문법이에요.  
	반복문을 사용하면 코드를 반복해서 실행할 수 있어 아주 편리하고 
	강력합니다.
	
"리스트에 들어 있는 값들을 하나씩 꺼내서 반복 실행하는 구조"입니다.

📖 문법, 구문(syntax): 
```python
for 변수 in 리스트:     
	실행할 코드
```

- 리스트 안에 있는 값이 하나씩 `변수`에 들어가며 `코드 블록`이 실행됨
- 리스트에 값이 5개면 코드가 5번 실행됨
---
</> 예시코드: 대소문자 섞인 리스트에서 모두 소문자로 바꿔 출력하기
```python
colors = ["Red", "GREEN", "bLue", "YELLOW"]

for color in colors:
    print(color.lower())
```

🖨️ 출력 결과:
```python
red  
green  
blue  
yellow
```

🔍 해설:
- `str.lower()`를 사용하여 대소문자 섞인 값을 모두 소문자로 통일해 출력
- 문자열 전처리 시 자주 쓰이는 방식

---
</> 예시코드: 숫자 리스트 중 짝수만 2배로 출력, 나머지는 무시
```python
nums = [4, 7, 10, 3, 8]

for n in nums:
    if n % 2 == 0:
        print(n * 2)
```

🖨️ 출력 결과:
```python
8  
20  
16
```

🔍 해설:
-  짝수만 필터링 (`n % 2 == 0`)
- 짝수일 경우에만 2배로 곱해서 출력
- 실무에서도 데이터 필터링 시 자주 사용

---
</> 예시코드: 음식 리스트에서 'bread'가 포함된 항목만 영어 문장으로 출력
```python
foods = ["banana bread", "rice", "bread", "noodles", "garlic bread"]

for food in foods:
    if "bread" in food:
        print(f"{food} contains bread!")
```

🖨️ 출력 결과:
```python
banana bread contains bread!  
bread contains bread!  
garlic bread contains bread!
```

🔍 해설:
- 리스트에서 꺼낸 문자열 `food`를 활용해 문장을 만들어 출력
---
</> 예시코드: 문자열 리스트의 첫 글자만 모아서 새 리스트로 만들기
```python
names = ["Alice", "Bob", "Michael", "Diana"]
first_letters = []

for name in names:
    first_letters.append(name[0])

print(first_letters)
```

🖨️ 출력 결과:
```python
['A', 'B', 'M', 'D']
```

🔍 해설:
- 문자열 인덱싱으로 첫 글자 추출
- 추출된 값을 다른 리스트에 저장
- 리스트 변환과 축약에 유용한 방식
---
📝 문제1] 숫자 리스트에서 3의 배수만 출력하세요.
```python
nums = [4, 6, 7, 9, 12, 15, 18]
```

🖨️ 출력 결과:
```python
6  
9  
12  
15  
18
```

✅ 정답 코드:
```python
nums = [4, 6, 7, 9, 12, 15, 18]

for n in nums:
    if n % 3 == 0:
        print(n)
```

🔍 해설:
- `n % 3 == 0` 조건으로 3의 배수만 필터링하여 출력
---
📝 문제2] 동물 리스트에 대해 `"I like ___"` 형식으로 출력하되,
"cat"일 때만 "I love cat" 이라고 출력하세요.
```python
animals = ["dog", "cat", "fox"]
```

🖨️ 출력 결과:
```python
I like dog  
I love cat  
I like fox
```

✅ 정답 코드:
```python
animals = ["dog", "cat", "fox"]

for animal in animals:
    if animal == "cat":
        print("I love cat")
    else:
        print("I like " + animal)
```

🔍 해설:
- 특정 값("cat")일 때만 예외 처리
- `if-else` 조건문을 반복문 안에 사용
---
💡 요약:

|문법|역할|
|---|---|
|`for 변수 in 리스트:`|리스트에서 하나씩 값을 꺼내 반복 실행|
|`range(n)`|숫자 0부터 n-1까지 생성하여 반복|
|`append()`|입력받은 값을 리스트에 추가|

✅ `for` 반복문은 리스트와 함께 사용할 때  
정해진 횟수만큼 자동 반복되는 구조로 초보자에게 매우 유용한 기본 문법입니다.

---
# 🔹 for 반복문: 리스트와 함께 사용하기
	for 반복문은 리스트와 함께 쓰면 가장 강력한 기능을 발휘해요.  
	리스트에 들어 있는 값들을 하나씩 꺼내며 반복 처리하기 때문에  
	정해진 데이터들을 순서대로 처리할 때 꼭 필요한 문법입니다.

</> 예시코드: 과일 리스트를 출력하기
```python
fruits = ["apple", "banana", "cherry"]

for fruit in fruits:
    print(fruit.upper())
```

🖨️ 출력 결과:
```python
APPLE  
BANANA  
CHERRY
```

🔍 해설:
- `for fruit in fruits:` → 리스트 요소만 순차적으로 가져옴
- `fruit.upper()` → 대문자로 변환하여 출력

---
</> 예시코드:  리스트 값 변형 + 조건문 + 새 리스트 생성
```python
scores = [70, 80, 90]
adjusted_scores = []

for score in scores:
    new_score = score + 10 # new_score = 80 90 100
    adjusted_scores.append(new_score) 

for score in adjusted_scores:
    if score >= 90:
        print(f"{score}점 (우수)")
    else:
        print(f"{score}점 (보통)")
```
---
`리스트이름.append(값)` 문법구조
- `adjusted_scores` : 리스트 빈그릇
- `append()` : 리스트에 값을 하나 추가하는 함수 (뒤에 붙임)
- `new_score` : 추가할 값 (변수든 숫자든 문자열이든 가능)
---
🖨️ 출력 결과:
```python
80점 (보통)
90점 (우수)
100점 (우수)
```

🔍 해설:
- `scores` 리스트에는 원래 점수들이 저장되어 있습니다.
- 첫 번째 `for`문은 각 점수에 10점을 더해서 `new_score`를 만든 뒤, `adjusted_scores`라는 새로운 리스트에 저장합니다.
- 두 번째 `for`문은 `adjusted_scores` 리스트를 순회하면서 점수가 90 이상이면 `(우수)`, 그렇지 않으면 `(보통)`이라고 출력합니다.
- 이 과정에서 리스트를 가공하고, 조건에 따라 다르게 출력하는 연습까지 포함되어 있어 `for + 리스트 활용`에 대한 이해를 심화시킬 수 있습니다.
---
</> 예시코드: 고객 데이터 기반 환영 메시지 생성기
```python
customer_names = ["홍길동", "김미정", "이수현", "박", "최민수"]

welcome_messages = []

for name in customer_names:
    name_length = len(name)
    first_char = name[0]
	
    if name_length <= 2:
        message = f"{name}님, 짧고 기억하기 쉬운 이름이네요!"
    elif name_length == 3:
        message = f"{name}님, 안정적인 세글자의 이름이시군요!"
    else:
        message = f"{name}님, 정중한 인상을 주는 이름이시군요."
		
    welcome_messages.append({
        "customer": name,
        "message": message,
        "first_letter": first_char,
        "name_length": name_length
    })
		
for entry in welcome_messages:
    print(f"[고객: {entry['customer']}] → {entry['message']}")
```

✅ 내부 작동순서
 메모리에 리스트 생성
```python
customer_names = ["홍길동", "김미정", "이수현", "박", "최민수"]
welcome_messages = []
```

 `for name in customer_names:` 반복 시작
- 파이썬은 `customer_names` 리스트의 요소를 하나씩 꺼내며 반복 실행합니다.

🔄 1회차 (name = "홍길동")
```python
name_length = len(name)
	- len("홍길동") → 3   
	- 정수 3이 name_length 변수에 저장됨
    
first_char = name[0]
	- 문자열 인덱싱: "홍길동"[0] → '홍'
	- 문자 '홍'이 first_char 변수에 저장됨
```

조건문실행
```python
if name_length <= 2:       → False
elif name_length == 3:     → True 
```
→ `message` 변수에  
`"홍길동님, 안정적인 세글자의 이름이시군요!"` 저장됨

`append()` 딕셔너리 객체 생성
```python
{
  "customer": "홍길동",
  "message": "홍길동님, 안정적인 세글자의 이름이시군요!",
  "first_letter": "홍",
  "name_length": 3
}
```
- 이 딕셔너리를 `welcome_messages` 리스트에 **추가** (`append` 호출)

🔁 최종 출력 루프
```python
for entry in welcome_messages:
    print(f"[고객: {entry['customer']}] → {entry['message']}")
```
- 리스트 `welcome_messages`를 하나씩 순회하며,
- 각 `entry` 딕셔너리에서 `['customer']`, `['message']` 값을 꺼내
- `print()`를 통해 출력

🖨️ 출력 결과:
```python
[고객: 홍길동] → 홍길동님, 안정적인 세글자의 이름이시군요!
[고객: 김미정] → 김미정님, 안정적인 세글자의 이름이시군요!
[고객: 이수현] → 이수현님, 안정적인 세글자의 이름이시군요!
[고객: 박] → 박님, 짧고 기억하기 쉬운 이름이네요!
[고객: 최민수] → 최민수님, 안정적인 세글자의 이름이시군요!
```

---
📝 문제1] 아래 리스트의 모든 문자에 `"는 알파벳입니다"`라는 문장을 붙여 출력하세요.

단, 모든 문자는 대문자로 출력되도록 하세요.
```python
letters = ["a", "b", "c"]
```

🖨️ 출력 결과:
```python
A는 알파벳입니다  
B는 알파벳입니다  
C는 알파벳입니다
```

✅ 정답 코드:
```python
letters = ["a", "b", "c"]

for ch in letters:
    print(ch.upper() + "는 알파벳입니다")
```

🔍 해설:
- `upper()`를 활용해 소문자를 대문자로 변환
- 문자열 덧셈으로 문장을 완성

---
📝 문제2] 리스트에 저장된 숫자를 반복문으로 출력하되,
짝수는 `[짝수]`, 홀수는 `(홀수)` 형식으로 출력하세요.
```python
employee_ids = [101, 102, 103, 104]
```

🖨️ 출력 결과:
```python
(101)  
[102]  
(103)  
[104]
```

✅ 정답 코드:
```python
employee_ids = [101, 102, 103, 104]

for eid in employee_ids:
    if eid % 2 == 0:
        print(f"[{eid}]")  # 정규직
    else:
        print(f"({eid})")  # 계약직
```

🔍 해설:
- `eid % 2 == 0`: 직원 ID가 짝수이면 정규직
- `else`: 홀수이면 계약직
- 조건문으로 출력 형식을 분기해서 구분된 메시지를 출력

---
📝 문제3] 사용자 이름 리스트가 주어졌을 때,
고객 이름 리스트가 주어졌습니다.
- 이름 길이에 따라 사용자 등급을 분류하세요.
    - 2글자 이하: `"단명 사용자"`
    - 3글자: `"일반 사용자"`
    - 4글자 이상: `"프리미엄 사용자"`

- 출력 형식은 아래와 같이 구성하세요:  
    이름 (글자 수) → 사용자 등급
```python
names = ["유나", "정우", "세바스찬", "김재민", "수"]
```

🖨️ 출력 결과:
```python
유나 (2글자) → 단명 사용자  
정우 (2글자) → 단명 사용자  
세바스찬 (4글자) → 프리미엄 사용자  
김재민 (3글자) → 일반 사용자  
수 (1글자) → 단명 사용자
```

✅ 정답 코드:
```python
names = ["유나", "정우", "세바스찬", "김재민", "수"]

for name in names:
    length = len(name)

    if length <= 2:
        level = "단명 사용자"
    elif length == 3:
        level = "일반 사용자"
    else:
        level = "프리미엄 사용자"

    print(f"{name} ({length}글자) → {level}")
```

🔍 해설:
- `len()`으로 글자 수를 구하고
- 조건문으로 길이가 3 이상인 경우 추가 메시지를 출력

---
# 🔹 중첩 리스트와 중첩 반복문
	리스트 안에 또 다른 리스트가 들어 있는 구조를 중첩 리스트
	(nested list)라고 합니다.  
	이때, 안쪽 리스트의 값을 다루기 위해서는 반복문을 반복문 안에 넣는 
	중첩 반복문을 사용합니다.

==네스티드==

리스트가 2차원 표처럼 행과 열로 구성되어 있을 때,  
for문을 두 번 써서 각 값을 꺼내는 방법이 바로 중첩 반복문입니다.

📖 문법, 구문(syntax): 
```python
list_of_list = [
    [1, 2, 3],      # 첫 번째 행 (리스트)
    [4, 5, 6, 7],   # 두 번째 행
    [8, 9]          # 세 번째 행
]
```

- `list_of_list` 는 3개의 리스트를 요소로 가진 리스트 → 3행 다열 구조
- `list_of_list[0]` → `[1, 2, 3]`
- `list_of_list[0][1]` → `2` (0번째 줄의 1번째 값)

---
</> 예시코드: 중첩 리스트 내부 리스트 출력하기
```python
list_of_list = [
    [1, 2, 3],      
    [4, 5, 6, 7],   
    [8, 9]         
] 

for items in list_of_list:
    print(items)
```

🖨️ 출력 결과:
```python
[1, 2, 3]
[4, 5, 6, 7]
[8, 9]
```

---
</> 예시코드:  중첩 반복문으로 내부 값 하나씩 출력하기
```python
for items in list_of_list:  # 바깥 리스트에서 내부 리스트 하나씩 꺼냄
    for item in items:   # 내부 리스트에서 요소 하나씩 꺼냄
        print(item)
```

🖨️ 출력 결과:
```python
1
2
3
4
5
6
7
8
9
```


```python
for items in list_of_list: -> [1, 2, 3]
    for item in items:  1,2,3
        print(item) 1 2 3 출력

for items in list_of_list: -> [4, 5, 6, 7]
    for item in items:  4,5,6,7
        print(item) 4 5 6 7 출력

for items in list_of_list: -> [8, 9]
    for item in items:  8,9
        print(item) 8 9 출력
```

🔍 해설: 출력순서
- 첫번째 for문에서 중첩 리스트의 첫번째가 호출되고
- 두번째 for문에서 호출된 리스트가 다시 펼쳐져서 호출됩니다.
---
📝 문제1] 다음 중첩 리스트에서 숫자를 하나씩 출력하되, 짝수는 "짝수", 홀수는 "홀수" 라는 표시도 함께 출력하세요.
```python
nums = [     
	[1, 2, 3],     
	[4, 5, 6] 
]
```

🖨️ 출력 결과:
```python
1 → 홀수  
2 → 짝수  
3 → 홀수  
4 → 짝수  
5 → 홀수  
6 → 짝수
```

✅ 정답 코드:
```python
for row in nums:
    for num in row:
        if num % 2 == 0:
            print(f"{num} → 짝수")
        else:
            print(f"{num} → 홀수")
```

🔍 해설:
- `num % 2 == 0`을 통해 짝수/홀수를 판단합니다.
- 조건문을 통해 각 숫자의 속성을 문장으로 표현합니다.
---
📝 문제2] 다음 2차원 리스트에서 `"철수"`가 성인인지 확인하고, 출력 형식을 아래처럼 꾸며보세요.

출력 형식: `"철수님은 25세로 성인입니다."`  
성인은 나이가 20세 이상인 사람으로 간주합니다.
```python
people = [
    ["영희", 22],
    ["철수", 25],
    ["민수", 18]
]
```

🖨️ 출력 결과:
```python
영희님은 22세로 성인입니다.  
철수님은 25세로 성인입니다.  
민수님은 18세로 미성년자입니다.
```

✅ 정답 코드: 
```python
people = [
    ["영희", 22],
    ["철수", 25],
    ["민수", 18]
]

for person in people:
    name, age = person

    if age >= 20:
        status = "성인"
    else:
        status = "미성년자"

    print(f"{name}님은 {age}세로 {status}입니다.")
```

✅ 정답 코드: 삼항조건식으로 표현
```python
people = [
    ["영희", 22],
    ["철수", 25],
    ["민수", 18]
]

for person in people:
    name, age = person
    status = "성인" if age >= 20 else "미성년자"
    print(f"{name}님은 {age}세로 {status}입니다.")
```

🔍 해설:
- 리스트의 각 요소를 `name`, `age`로 언팩(분해)합니다.
- `삼항 조건식`을 사용해 성인/미성년자 판단 후 메시지를 출력합니다.
---
# 🔹 전개 연산자
	전개 연산자(spread operator)는 * 기호를 사용해 리스트나 튜플처럼 
	여러 개의 값이 들어 있는 자료를 하나하나 꺼내서 펼쳐주는 기호입니다.

"리스트 안에 있는 값들을 하나씩 꺼내서 펼쳐주는 도구"가 전개 연산자입니다.

==스프레드 오퍼레이터==

---
###### ◽ 사용 위치에 따라 다른 역할
| 사용 위치             | 동작 예시               | 설명                |
| ----------------- | ------------------- | ----------------- |
| 함수 호출 시           | `print(*[1, 2, 3])` | 각각의 값으로 분해해서 전달   |
| 리스트 결합 시          | `[1, *[2, 3], 4]`   | 리스트 안 리스트를 펼쳐서 합침 |
| 함수 정의 시 (`*args`) | `def func(*args):`  | 여러 개 인자를 한 번에 받음  |

---
</> 예시코드: 리스트 안 값을 하나씩 꺼내 출력
```python
nums = [1, 2, 3] 
print(nums)
print(*nums)
```

🖨️ 출력 결과:
```python
[1, 2, 3]
1 2 3
```

🔍 해설:
- `*nums`는 리스트 `[1, 2, 3]`을 각각 `1`, `2`, `3`으로 분해
- `print()` 함수에 여러 인자를 넘기는 효과
- `print(nums)`와는 결과가 다름 → `print(nums)`는 `[1, 2, 3]` 전체 출력

---
</> 예시코드: 리스트 결합 시 중첩 없이 펼치기
```python
a = [1, 2]
b = [3, 4]

result1 = [*a, *b]
result2 = [a, b]

print(result1)
print(result2)
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4]
[[1, 2], [3, 4]]
```

🔍 해설:
- `*a`는 리스트 `[1, 2]`의 요소를 풀어서 삽입
- 중첩 리스트 없이 하나의 리스트로 합쳐짐
---
</> 예시코드: 문자열도 전개 가능
```python
text = "abc"
print(text)
print(*text)
```

🖨️ 출력 결과:
```python
abc
a b c
```

🔍 해설:
- 문자열 `"abc"`도 반복 가능한 객체 → 각 문자로 분해 출력
---
</> 예시코드: 고객 주문 데이터를 병합하고 요약 출력하기
```python
# 매장별 오늘의 주문 리스트
orders_branch_A = ["김밥", "라면"]
orders_branch_B = ["떡볶이", "순대"]
orders_branch_C = ["김말이", "튀김"]

# 전부 합쳐서 본사 집계용 리스트로 생성
all_orders = [*orders_branch_A, *orders_branch_B, *orders_branch_C]

# 중복 제거 후 정렬
unique_orders = sorted(set(all_orders))

# 요약 출력
print(f"오늘 총 주문 건수: {len(all_orders)}건")
print(f"주문된 메뉴 목록 ({len(unique_orders)}종류):")
print(", ".join(unique_orders))
```

```python
orders_branch_A = ["김밥", "라면"]
orders_branch_B = ["떡볶이", "순대"]
orders_branch_C = ["김말이", "튀김"]

all_orders = [*orders_branch_A, *orders_branch_B, *orders_branch_C]
`all_orders` = ['김밥', '라면', '떡볶이', '순대', '김말이', '튀김']

unique_orders = sorted(set(all_orders))
`unique_orders` = ['김말이', '김밥', '떡볶이', '라면', '순대', '튀김'] 

print(f"오늘 총 주문 건수: {len(all_orders)}건") -> 6
print(f"주문된 메뉴 목록 ({len(unique_orders)}종류):") -> 6종류
print(", ".join(unique_orders)) -> 김말이, 김밥, 떡볶이, 라면, 순대, 튀김
```
- `", "` 각 요소 사이에 들어갈 문자열 (구분자)
- `.join([...])` 리스트의 요소를 하나씩 꺼내서 문자열로 연결


🖨️ 출력 결과:
```python
오늘 총 주문 건수: 6건
주문된 메뉴 목록 (6종류):
김말이, 김밥, 떡볶이, 라면, 순대, 튀김
```

🔍 해설:
- `[*A, *B, *C]` 전개 연산자 `*`를 써서 여러 리스트를 하나로 합침
- `set(all_orders)` 중복된 메뉴를 제거 (예: 같은 메뉴가 여러 지점에서 주문됨)
- `sorted()` 메뉴명을 가나다순으로 정렬
- `", ".join(...)` 문자열로 이어서 출력 (CSV처럼 보기 좋게)
---
###### ◽ 리스트 컴프리헨션 (List Comprehension)
	리스트 컴프리헨션은 기존 리스트나 반복 가능한 값들로부터 새로운 
	리스트를 간단한 문법으로 만드는 방법입니다.
	일반적인 for 반복문을 한 줄로 줄여주는 간결하고 직관적인 표현식
	입니다. 람다함수나 삼항 조건 연산자와 같이 for문을 간결하게 표현
	하는 방식입니다.

📖 문법, 구문(syntax): 
```python
[표현식 for 변수 in 반복가능한_값들 if 조건]
```
- `표현식` : 리스트에 담을 값
- `for` : 반복문 (기존 리스트나 range 등에서 하나씩 꺼냄)
- `if 조건` (선택사항) : 조건을 만족하는 값만 포함

</>예시코드:
```python
# 일반적인 for문
numbers = [1, 2, 3, 4, 5]
squares = []  # 결과를 담을 빈 리스트 만들기

for n in numbers:
    squares.append(n * n)

print(squares)

# 리스트 컴프리헨션 버전
numbers = [1, 2, 3, 4, 5]
squares = [n * n for n in numbers]
print(squares)
```

🖨️ 출력:
```python
[1, 4, 9, 16, 25]
```

🔍 해설:
- 기존 리스트 `numbers`에서 각 숫자를 제곱해서 새 리스트에 저장.

</>예시코드:
```python
# 일반적인 for문
numbers = [1, 2, 3, 4, 5]
even = []  # 짝수만 담을 빈 리스트

for n in numbers:
    if n % 2 == 0:        # 짝수 조건
        even.append(n)

print(even)


# 리스트 컴프리헨션 버전
numbers = [1, 2, 3, 4, 5]
even = [n for n in numbers if n % 2 == 0]
print(even)
```

🖨️ 출력:
```python
[2, 4]
```

🔍 해설:
 `even = []`  
    먼저, 짝수만 따로 모아 둘 빈 리스트를 하나 만들어 둡니다.
    
 `for n in numbers`  
    `numbers` 리스트에 있는 숫자들을 하나씩 꺼내서 `n`이라는 이름으로 
    사용합니다.
    
 `if n % 2 == 0`  
	 꺼낸 숫자가 2로 나누어 떨어지는지, 즉 짝수인지 검사합니다.
	 
`even.append(n)`  
    만약 그 숫자가 짝수라면, 결과 리스트(`even`)에 추가합니다.

---
📝 문제1] 리스트 `[10, 20, 30]`을 `print()`로 전개해 출력해보세요.  
(단, 대괄호 없이 숫자만 보이게)
```python
nums = [10, 20, 30]
```

🖨️ 출력 결과:
```python
10 20 30
```

✅ 정답 코드:
```python
nums = [10, 20, 30] 
print(*nums)
```

🔍 해설:
- `*nums`는 `10`, `20`, `30`을 개별 인자로 넘김
- `print()`는 자동으로 공백으로 구분하여 출력
---
📝 문제2] 리스트 `[1, 2]`와 `[3, 4]`를 전개 연산자로 합쳐보세요.
```python
a = [1, 2] 
b = [3, 4]
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4]
```

✅ 정답 코드:
```python
a = [1, 2] 
b = [3, 4] 
combined = [*a, *b] 
print(combined)
```

🔍 해설:
- `*a`, `*b`는 각각의 리스트 요소를 하나씩 풀어서 새 리스트에 추가
---
📝 문제3] 여러 개의 중첩된 리스트가 다음과 같이 존재할 때,  
전개 연산자 없이 `flatten`(평탄화)하여 하나의 리스트로 결합해보세요.
```python
data = [[1, 2], [3, 4], [5, 6]]
```

🖨️ 출력 결과:
```python
[1, 2, 3, 4, 5, 6]
```

✅ 정답 코드: 중첩 반복문 사용
```python
data = [[1, 2], [3, 4], [5, 6]]
flattened = []

for group in data:
    for item in group:
        flattened.append(item)

print(flattened)
```

✅ 정답 코드: 리스트 컴프리헨션
```python
data = [[1, 2], [3, 4], [5, 6]]
flattened = [item for group in data for item in group]
print(flattened)
```

🔍 해설:
- 리스트끼리의 `+` 연산도 내부적으로는 전개와 유사한 효과
- 하지만 전개 연산자는 함수 호출이나 가변 인자 처리에도 사용 가능함
---
###### ◽  리스트(List) – 단일 열(column) 형태의 데이터 저장
	리스트는 같은 종류의 데이터(이름, 상품명, 숫자 등)를 순차적으로 
	저장할 때 사용합니다.

- 사용자 이메일 목록:
    ```python
user_emails = [
    "alice@example.com",
    "bob@example.com",
    "charlie@example.com"
]
```

- API 요청 응답 시간(ms)
    ```python
response_times = [120, 240, 180, 95, 305]  # 밀리초 단위
```

- 재고 알림 상품 ID 리스트
    ```python
low_stock_product_ids = [1023, 2048, 3056, 4981]
```

---
###### ◽  2차원 리스트 (2D List) – 표(table) 형태의 데이터 저장
	행(Row) 과 열(Column) 이 있는 데이터를 표현할 때 사용합니다.  
	리스트 안에 또 다른 리스트를 포함한 구조이며, 엑셀 표 형식의 
	데이터에 적합합니다.
	 표처럼 행과 열로 정리된 데이터를 저장할 때 사용합니다.  
	 즉, 리스트 안에 리스트가 들어 있는 구조예요.

- 직원 근무 시간표 (요일별 근무 시간)
``` python
# 각 행 = 직원 1명 / 각 열 = 월~금 근무시간
work_hours = [
    [8, 8, 8, 8, 6],  # 직원 A
    [9, 9, 9, 9, 0],  # 직원 B
    [7, 7, 7, 7, 7]   # 직원 C
]
```
    
- 매출 데이터 (지점별 월간 매출)
```python
# 각 행 = 지점 / 각 열 = 1월~3월 매출(단위: 백만원)
branch_sales = [
    [120, 135, 150],   # 서울지점
    [90, 100, 110],    # 부산지점
    [70, 85, 95]       # 대구지점
]
```

- 상품 재고 상태
```python
# 상품 이름, 카테고리, 재고 수량
inventory = [
    ["우유", "식품", 20],
    ["마우스", "전자기기", 12],
    ["노트", "문구", 35]
]
```

---
###### ◽ 백엔드 파트에서의 데이터 처리과정
🔄 전체 흐름
1. 데이터 수집 (입력단)
    - 사용자가 **폼**, 앱, 웹사이트, 센서, 외부 API를 통해 데이터를 보냄
    - 입력값 예: 회원가입 정보, 주문내역, 센서 수치, 이미지, CSV 업로드 등

2. 입력 검증 (Validation)
    - 빈 값 체크, 타입 확인, 정규표현식 필터링 등으로 유효성 검증
    - 예: 이메일 형식 확인, 나이 숫자 여부 확인

3. 정제 및 정규화 (Normalization)
    - 대소문자 통일, 날짜 형식 통일, 중복 제거, 공백 제거
    - 예: `2025/5/13` → `2025-05-13`, `" Kim "` → `"kim"`

4. 저장 처리
    - ORM (Django, SQLAlchemy 등) 또는 SQL로 데이터베이스에 저장
    - 테이블 간 ForeignKey 관계 정리 필요 (정규화된 구조)

5. 가공 및 반환
    - 요청에 맞춰 필터링, 정렬, 집계
    - 가공된 데이터를 API 응답으로 제공 (JSON 등)
        
6. 로깅 및 예외 처리
    - 실패 로그 저장 (ex. 로그인 실패)
    - 에러 발생 시 사용자에게 명확한 메시지 전달

---
###### ◽ AI 파트에서의 데이터 처리과정
🔄 전체 흐름
1. 데이터 수집
    - 백엔드(DB)에서 추출하거나, 로그 서버, 센서, 크롤러, 외부 API 활용
    - 일반적으로는 CSV/JSON 또는 SQL 쿼리로 받은 원천 데이터

2. 전처리 (Preprocessing)
    - 결측값 보정 (NaN → 평균/중앙값 등)
    - 이상치 제거 (Z-score, IQR)
    - 범주형 → 수치형 인코딩 (LabelEncoding, OneHotEncoding)
    - 정규화/표준화 (MinMax, Z-score)

3. 특성 엔지니어링 (Feature Engineering)
    - 기존 데이터를 조합하거나 파생변수 생성
    - 예: 로그인 시간 → '야간/주간' 구분, 금액 → 등급화

4. 데이터 분할
    - 학습/검증/테스트 세트로 나눔 (train/test split)
    - 교차검증이 필요한 경우 K-Fold 적용

5. 모델 학습 및 튜닝
    - 알고리즘 적용 (예: XGBoost, YOLO, LSTM 등)
    - 하이퍼파라미터 조정
    - 성능 평가 (정확도, F1-score 등)

6. 추론 및 결과 활용
    - 예측 결과를 다시 DB로 저장하거나 API로 반환
    - 실시간 추천, 이상탐지, 분류 결과 등 서비스에 적용

7. 시각화 및 리포팅
    - Pandas/Matplotlib/Seaborn으로 분석 결과 시각화
    - 경영진 보고용 또는 운영 대시보드로 제공


----
# 💭직접 풀어보세요.

📝 문제1]
이름 목록이 담긴 리스트에서 각 이름의 글자 수를 세어, 다음과 같은 형식으로 출력해보세요.
```python
names = ["Tom", "Alice", "Jonathan"]
```

🖨️ 출력 결과:
```python
Tom는 3글자입니다.
Alice는 5글자입니다.
→ 이름이 깁니다
Jonathan는 8글자입니다.
→ 이름이 깁니다
```

✅ 정답 코드:
```python
names = ["Tom", "Alice", "Jonathan"]

for name in names:
    length = len(name)
    print(f"{name}는 {length}글자입니다.")
    if length >= 4:
        print("→ 이름이 깁니다")
```

🔍 해설:
- 짝수 필터링 후 리스트에 저장
- `sorted()`로 오름차순 정렬
---
📝 문제2]
학생들의 점수가 담긴 2D 리스트가 있습니다. 각 학생의 평균 점수를 계산해서 출력하고,  평균이 90점 이상이면 "→ 우수"라고 출력하세요.
```python
scores = [
    [100, 90, 80],
    [70, 75, 72],
    [95, 98, 92]
]
```

🖨️ 출력 결과:
```python
학생 1의 평균 점수: 90.0 → 우수
학생 2의 평균 점수: 72.33
학생 3의 평균 점수: 95.0 → 우수
```

✅ 정답 코드:
```python
scores = [
    [100, 90, 80],
    [70, 75, 72],
    [95, 98, 92]
]

for i in range(len(scores)):
    student = scores[i]
    avg = sum(student) / len(student)
    print(f"학생 {i + 1}의 평균 점수: {round(avg, 2)}", end="")
    if avg >= 90:
        print(" → 우수")
    else:
        print()
```

🔍 해설:
- `range(len(scores))`:  학생 수만큼 반복 (총 3명)
- `scores[i]`:   i번째 학생의 점수 리스트
- `sum(student) / len(student)`:  점수의 합을 과목 수로 나누어 평균 계산
- `round(..., 2)`:  소수점 둘째 자리까지 반올림
- `if avg >= 90:`:  평균이 90 이상인 경우 "→ 우수" 표시
---
📝 문제3]
점수 리스트에서 모든 점수에 5점을 더해서 출력해보세요.
```python
numbers = [9, 2, 5, 8, 11, 6]
```

🌟 힌트:
- 리스트 값에 직접 +5를 해보세요.

🖨️ 출력 결과:
```python
[2, 6, 8]
```

✅ 정답 코드:
```python
numbers = [9, 2, 5, 8, 11, 6]
evens = []

for n in numbers:
    if n % 2 == 0:
        evens.append(n)

print(sorted(evens))
```

🔍 해설:
- 짝수 필터링 후 리스트에 저장
- `sorted()`로 오름차순 정렬
---
📝 문제4]
리스트에 있는 숫자들을 하나씩 출력하세요.
```python
numbers = [10, 20, 30, 40, 50]
```

🌟 힌트:
- 중첩 반복문(이중 for문)을 사용해야 모든 값을 꺼낼 수 있어요.

🖨️ 출력 결과:
```python
10  
20  
30  
40  
50
```

✅ 정답 코드:
```python
numbers = [10, 20, 30, 40, 50]

for num in numbers:
    print(num)
```

🔍 해설:
- `for num in numbers:`는 리스트에 들어 있는 값을 하나씩 꺼냅니다.
- 꺼낸 값을 `print()`로 출력합니다.
---
📝 문제5]
이름과 나이를 저장한 리스트가 있을 때, 다음 형식으로 출력해보세요.  
→ `"이름님은 XX세입니다."`
```python
people = [
    ["민준", 28],
    ["서연", 31],
    ["지훈", 24]
]
```

🖨️ 출력 결과:
```python
민준님은 28세입니다.  
서연님은 31세입니다.  
지훈님은 24세입니다.
```

✅ 정답 코드:
```python
people = [
    ["민준", 28],
    ["서연", 31],
    ["지훈", 24]
]

for person in people:
    name, age = person
    print(f"{name}님은 {age}세입니다.")
```

🔍 해설:
- 이중 리스트에서 각 요소는 `[이름, 나이]` 형식입니다.
- 변수 분해(unpacking)로 `name`, `age`를 나누고 출력합니다.
---
📝 문제6] 
다음 2차원 리스트의 모든 값을 출력하되,  
짝수는 `[짝수: 값]`, 홀수는 `(홀수: 값)` 형식으로 출력하세요.
```python
matrix = [
    [10, 15],
    [22, 33],
    [40, 41]
]
```

🖨️ 출력 결과:
```python
[짝수: 10]  
(홀수: 15)  
[짝수: 22]  
(홀수: 33)  
[짝수: 40]  
(홀수: 41)
```

✅ 정답 코드:
```python
matrix = [
    [10, 15],
    [22, 33],
    [40, 41]
]

for row in matrix:
    for value in row:
        if value % 2 == 0:
            print(f"[짝수: {value}]")
        else:
            print(f"(홀수: {value})")
```

🔍 해설:
- 바깥 `for`는 행(row), 안쪽 `for`는 각 값(value)을 순회합니다.
- `value % 2`로 홀짝 판별 후 다른 출력 형식 적용
---
두 리스트를 출력해보세요.
```python
list_a = [1, 2, 3]
list_b = [4, 5, 6]
```
아래 물음에 답하거나 빈칸을 채우세요.

📝 문제7] 리스트 출력하기
두 리스트를 각각 출력하세요.
```python
print("list_a =", ____________)
print("list_b =", ____________)
```

✅ 정답 코드:
```python
list_a = [1, 2, 3]
list_b = [4, 5, 6]

print("list_a =", list_a)
print("list_b =", list_b)
```

🖨️ 출력 결과:
```python
list_a = [1, 2, 3]
list_b = [4, 5, 6]
```

---
📝 문제8] 
두 리스트를 합치면 어떤 결과가 나오는지 예측하고 출력해보세요.
```python
list_a = [1, 2, 3]
list_b = [4, 5, 6]
```

```python
print("합쳐진 리스트 =", ____________________)
```

🖨️ 출력 결과:
```python
합쳐진 리스트 = [1, 2, 3, 4, 5, 6]
```

✅ 정답 코드:
```python
print("합쳐진 리스트 =", list_a + list_b)
```

🔍 해설:
- `+` 연산자는 두 리스트를 이어 붙입니다.
- 리스트 자체는 변하지 않으며, 새로운 리스트가 만들어집니다.

---
📝 문제9] 
리스트 곱셈 연산을 사용하여 다음 조건을 만족하세요.
- `list_a`를 2번 반복
- `list_b`를 3번 반복
- 두 결과를 이어 붙여 하나의 리스트로 출력하세요.
```python
list_a = ["A", "B"]
list_b = ["X", "Y"]
```

```python
['A', 'B', 'A', 'B', 'X', 'Y', 'X', 'Y', 'X', 'Y']
```

🖨️ 출력 결과:
```python
list_a = ["A", "B"]
list_b = ["X", "Y"]

result = list_a * 2 + list_b * 3
print(result)
```

🔍 해설:
- `list * N`은 리스트를 N번 반복합니다.
- `+`는 두 리스트를 연결합니다.
- 실무에서 샘플 데이터 생성이나 패턴 반복 출력 등에 자주 사용됩니다.
---
📝 문제 10] 
리스트에서 특정 위치의 요소를 삭제해보세요.
```python
nums = [10, 20, 30, 40, 50]
```
2번째 요소(`20`)를 삭제하고, 리스트를 출력해보세요.

🖨️ 출력 결과:
```python
[10, 30, 40, 50]
```

✅ 정답 코드:
```python
nums = [10, 20, 30, 40, 50]
del nums[1]
print(nums)
```

🔍 해설:
- `del` 키워드는 특정 위치의 값을 **삭제**합니다.
- 인덱스는 `0`부터 시작하므로 `nums[1]`은 `20`입니다.
---
📝 문제 11]
pop()을 사용해 리스트에서 값을 꺼내고 삭제하세요.  
또한 꺼낸 값도 함께 출력해보세요.
```python
nums = [100, 200, 300, 400]
```
인덱스 2의 값을 꺼내어 출력하고, 남은 리스트를 출력하세요.

🖨️ 출력 결과:
```python
꺼낸 값: 300  
남은 리스트: [100, 200, 400]
```

✅ 정답 코드:
```python
nums = [100, 200, 300, 400]
value = nums.pop(2)
print("꺼낸 값:", value)
print("남은 리스트:", nums)
```

🔍 해설:
- `pop(2)`는 `300`을 꺼내고 리스트에서 자동으로 삭제합니다.
- 변수에 저장하면 꺼낸 값을 따로 출력할 수 있습니다.
---
📝 문제 12] 
리스트에서 특정 값을 찾아 삭제한 후, 변경된 리스트를 출력하세요.  
단, `remove()` 함수를 사용하세요.
```python
users = ["admin", "guest", "user01", "guest", "user02"]
```
`"guest"`를 **한 번만** 삭제하고 리스트를 출력해보세요.

🖨️ 출력 결과:
```python
['admin', 'user01', 'guest', 'user02']
```

✅ 정답 코드:
```python
users = ["admin", "guest", "user01", "guest", "user02"]
users.remove("guest")
print(users)
```

🔍 해설:
- `remove("값")`은 해당 값을 처음 발견된 위치에서 한 번만 삭제합니다.
- 같은 값이 여러 번 있더라도 한 번만 삭제됩니다.

---
###### 📝 문제10] 리스트 요소 제거하기
del 키워드를 사용하여 리스트 요소 삭제하기
다음과 같은 리스트가 있습니다:
```python
list_a = [0, 1, 2, 3, 4, 5]
```

아래 코드를 실행했을 때 결과를 예측해보세요:
```python
del list_a[1]
print("del list_a[1]:", list_a)
```

🖨️ 출력 결과:
```python
del list_a[1]: [0, 2, 3, 4, 5]
```

✅ 정답 코드:
```python
list_a = [0, 1, 2, 3, 4, 5]
del list_a[1]
print("del list_a[1]:", list_a)
```

🔍 해설:
- `del list_a[1]`은 인덱스 1의 값(=1)을 삭제
- 리스트는 `[0, 2, 3, 4, 5]`로 변경됨
---
📝 문제11] pop() 함수를 사용하여 요소 꺼내고 삭제하기
현재 리스트는 다음과 같습니다:
```python
list_a = [0, 2, 3, 4, 5]
```

다음 코드를 실행했을 때 결과는?
```python
list_a.pop(2)
print("pop(2):", list_a)
```

🖨️ 출력 결과:
```python
pop(2): [0, 2, 4, 5]
```

✅ 정답 코드:
```python
list_a = [0, 2, 3, 4, 5]
list_a.pop(2)
print("pop(2):", list_a)
```

🔍 해설:
- `list_a.pop(2)`은 인덱스 2의 값(=3)을 꺼내면서 삭제
- 리스트는 `[0, 2, 4, 5]`로 변경됨
---
📝 문제12] 리스트 요소 접근하기
리스트 `fruits = ['apple', 'banana', 'cherry']`에서 `'banana'`를 출력해보세요.

🖨️ 출력 결과:
```python
banana
```

✅ 정답 코드:
```python
fruits = ['apple', 'banana', 'cherry']
print(fruits[1])
```

🔍 해설: 
- 인덱스는 0부터 시작하므로 `fruits[1]`이 두 번째 요소인 `'banana'`를 가리킵니다.

---
📝 문제13] IndexError 예외
다음 코드의 실행 결과는 어떤 오류가 발생할까요?
```python
nums = [1, 2, 3]
print(nums[5])
```

🖨️ 출력 결과:
```python
IndexError
```

✅ 정답 코드:
```python
nums = [1, 2, 3]
print(nums[5])  # IndexError 발생
```

🔍 해설:
- 인덱스 5는 존재하지 않으므로 `IndexError`가 발생합니다.

---
📝 문제14] 리스트에서 튜플 수정하기
리스트 `data = [('철수', 20), ('영희', 22)]`에서 `'영희'`의 나이를 `23`으로 수정해보세요.

🖨️ 출력 결과:
```python
[('철수', 20), ('영희', 23)]
```

✅ 정답 코드:
```python
data = [('철수', 20), ('영희', 22)]
data[1] = ('영희', 23)
print(data)
```

🔍 해설:
튜플은 수정이 불가능하므로 전체 튜플을 새 값으로 대입해야 합니다.

---
📝 문제15] 리스트 연결 연산자 `+`
`a = [1, 2]`, `b = [3, 4]` 두 리스트를 연결해서 새 리스트로 출력해보세요.

🖨️ 출력 결과:
```python
[1, 2, 3, 4]
```

✅ 정답 코드:
```python
a = [1, 2]
b = [3, 4]
print(a + b)
```

🔍 해설:
`+` 연산자는 두 리스트를 하나로 합친 새 리스트를 생성합니다.

---
📝 문제16] 리스트 반복 연산자 `*`
리스트 `colors = ['red']`를 3번 반복한 리스트를 출력해보세요.

🖨️ 출력 결과:
```python
['red', 'red', 'red']
```

✅ 정답 코드:
```python
colors = ['red']
print(colors * 3)
```

🔍 해설:
- `* 정수`는 리스트를 반복하여 새로운 리스트를 만듭니다.
---
📝 문제17]  `len()`으로 요소 수 세기
리스트 `items = ['a', 'b', 'c']`에 몇 개의 요소가 있는지 출력해보세요.

🖨️ 출력 결과:
```python
3
```

✅ 정답 코드:
```python
items = ['a', 'b', 'c']
print(len(items))
```

🔍 해설:
- `len()` 함수는 리스트의 요소 개수를 반환합니다.

---
📝 문제18] `append()`로 요소 추가
`nums = [1, 2]`에 숫자 3을 추가한 뒤 출력해보세요.

🖨️ 출력 결과:
```python
[1, 2, 3]
```

✅ 정답 코드:
```python
nums = [1, 2]
nums.append(3)
print(nums)
```

🔍 해설:
`append()`는 리스트 맨 뒤에 새 요소를 추가합니다.

---
📝 문제19] `insert()`로 요소 삽입
리스트 `letters = ['a', 'c']`에 `'b'`를 인덱스 1 위치에 삽입해보세요.

🖨️ 출력 결과:
```python
['a', 'b', 'c']
```

✅ 정답 코드:
```python
letters = ['a', 'c']
letters.insert(1, 'b')
print(letters)
```

🔍 해설:
- `insert(index, value)`는 지정한 위치에 값을 삽입합니다.

---
📝 문제20]  `remove()`로 값 제거
리스트 `names = ['Tom', 'Jerry', 'Spike']`에서 `'Jerry'`를 제거해보세요.

🖨️ 출력 결과:
```python
['Tom', 'Spike']
```

✅ 정답 코드:
```python
names = ['Tom', 'Jerry', 'Spike']
names.remove('Jerry')
print(names)
```

🔍 해설:
- `remove(값)`은 리스트에서 해당 값을 찾아 삭제합니다.

---
📝 문제21] 리스트 정렬하기
리스트 `scores = [90, 70, 80]`을 오름차순으로 정렬하여 출력해보세요.

🖨️ 출력 결과:
```python
[70, 80, 90]
```

✅ 정답 코드:
```python
scores = [90, 70, 80]
scores.sort()
print(scores)
```

🔍 해설:
- `sort()`는 리스트 자체를 오름차순으로 정렬합니다.

---
📝 문제 5] 튜플의 조건에 따라 리스트 필터링
다음은 `(이름, 나이)` 형태의 튜플을 담고 있는 리스트입니다.  
30세 이상인 사람의 이름만 출력하세요.
```python
people = [("Tom", 25), ("Lucy", 32), ("Steve", 40), ("Emma", 28)]
```

🖨️ 출력 결과:
```python
Lucy
Steve
```

✅ 정답 코드: 인덱스를 활용한 `if` 조건문과 직접 접근 방식
```python
people = [("Tom", 25), ("Lucy", 32), ("Steve", 40), ("Emma", 28)]

if people[0][1] >= 30:
    print(people[0][0])

if people[1][1] >= 30:
    print(people[1][0])

if people[2][1] >= 30:
    print(people[2][0])

if people[3][1] >= 30:
    print(people[3][0])
```

✅ 정답 코드: for문 방식
```python
people = [("Tom", 25), ("Lucy", 32), ("Steve", 40), ("Emma", 28)]

for name, age in people:
    if age >= 30:
        print(name)
```

🔍 해설:
- 리스트 `people`에는 튜플(이름, 나이)이 들어 있음.
- `for name, age in people:` 구문은 튜플 언패킹.
- 조건문 `if age >= 30:`을 통해 필터링.
- 해당 조건을 만족하는 이름만 출력함.
---
📝 문제 6] 가장 나이가 많은 사람 찾기
아래의 리스트에서 가장 나이가 많은 사람의 이름과 나이를 출력하세요.
```python
people = [("Jane", 22), ("Alex", 35), ("Bob", 29), ("Hana", 31)]
```

🖨️ 출력 결과:
```python
가장 나이가 많은 사람은 Alex(35세)입니다.
```

✅ 정답 코드:
```python
people = [("Jane", 22), ("Alex", 35), ("Bob", 29), ("Hana", 31)]

max_person = people[0]  # 초기값 설정

for person in people:
    if person[1] > max_person[1]:  # 나이 비교
        max_person = person

print(f"가장 나이가 많은 사람은 {max_person[0]}({max_person[1]}세)입니다.")
```

🔍 해설:
- `max_person`을 처음엔 첫 번째 사람으로 설정
- 반복문으로 순회하면서 나이가 더 많으면 교체
- 마지막에 가장 나이 많은 사람을 출력
---
📝 문제7] 당신은 두 개의 리스트를 합쳐서 전체 메시지 순서를 만들려고 합니다.  하나는 인사말 리스트이고, 하나는 이모지 리스트입니다.
```python
greetings = ["Hello", "Nice to meet you"]
emojis = ["⭕", "❌"]
```
이 두 리스트를 하나로 합쳐 한 줄에 출력하려고 합니다.  두 리스트를 연결해서 출력하는 코드를 작성하세요.

🖨️ 출력 결과:
```python
['Hello', 'Nice to meet you', '⭕', '❌']
```

✅ 정답 코드:
```python
greetings = ["Hello", "Nice to meet you"]
emojis = ["🙂", "👋"]
print(greetings + emojis)
```

🔍 해설:
- `+` 연산자는 리스트를 **이어붙이는(연결하는)** 데 사용됨
- 두 리스트의 요소들이 순서대로 합쳐짐
---
📝 문제8] 학생 이름 `"Alex"`를 출석부에 3번 복사해서 추가하려고 합니다.  
복사된 리스트를 만들어 출력하세요.

🖨️ 출력 결과:
```python
['Alex', 'Alex', 'Alex']
```

✅ 정답 코드:
```python
attendance = ["Alex"] * 3
print(attendance)
```

🔍 해설:
- `["Alex"] * 3`은 `"Alex"`라는 요소가 3번 반복된 리스트 생성
- 리스트 전체가 반복되며 새로운 리스트를 만듦
---
📝 문제9] 다음은 수강생 목록입니다.
```python
students = ["Jin", "Sara", "Leo","Jin", "Min","Jin"]
```
이 리스트에 `"Jin"`이라는 이름이 몇 번 나오는지와 총 인원수를 `len()` 함수를 이용해 작성하세요.

🖨️ 출력 결과:
```python
Jin의 출현 횟수: 3
총 인원 수: 6
```

✅ 정답 코드:
```python
students = ["Jin", "Sara", "Leo", "Jin", "Min", "Jin"]

jin_count = students.count("Jin")
total_count = len(students)

print("Jin의 출현 횟수:", jin_count)
print("총 인원 수:", total_count)
```

🔍 해설:
- `students.count("Jin")`은 리스트 안에서 `"Jin"`이 몇 번 나오는지 세어줍니다.
- `len(students)`는 리스트 안의 전체 인원 수(요소 수)** 를 구합니다.
---
📝 문제1] 리스트 `[30, 10, 20]`을 오름차순으로 정렬해 출력해보세요.
```python
mixed = ["banana", "Apple", "가방", "123", "Zebra", "apple", "가나다"]
```

🖨️ 출력 결과:
```python
['123', 'Apple', 'Zebra', 'apple', 'banana', '가나다', '가방']
```

✅ 정답 코드:
```python
mixed = ["banana", "Apple", "가방", "123", "Zebra", "apple", "가나다"]
mixed.sort()
print(mixed)
```

🔍 해설:
- 기본 `sort()`는 유니코드 순서로 정렬.
- 숫자 → 대문자 → 소문자 → 한글 순으로 정렬됨.
---
📝 문제2] `"dog", "cat", "ant"`가 들어있는 리스트를 a b c순으로 정렬하세요.
```python
scores = [78, 95, 88, 100, 67, 84, 91]
```

🖨️ 출력 결과:
```python
[100, 95, 91]
```

✅ 정답 코드:
```python
scores = [78, 95, 88, 100, 67, 84, 91]
top_scores = sorted(scores, reverse=True)[:3]
print(top_scores)
```

🔍 해설:
- `sorted(..., reverse=True)`로 내림차순 정렬
- `[:3]` 슬라이싱으로 상위 3개만 추출
---
📝 문제3] 다음 리스트를 정렬하되, 대소문자를 구분하지 않고 알파벳순으로 정렬하세요.
```python
names = ["Tom", "alice", "BOB", "David", "carol"]
```

🖨️ 출력 결과:
```python
['alice', 'BOB', 'carol', 'David', 'Tom']
```

✅ 정답 코드:
```python
names = ["Tom", "alice", "BOB", "David", "carol"]
names.sort(key=str.lower)
print(names)
```

🔍 해설:
-  `key=str.lower`로 모두 소문자로 변환한 값을 기준으로 정렬
- 실제 리스트 안의 대소문자는 그대로 유지됨
---
📝 문제4] 다음 한글 이름 리스트를 가나다순으로 정렬하고, 정렬된 새 리스트를 출력하되 원본 리스트는 그대로 유지하세요.
```python
students = ["김민수", "이수정", "박지훈", "최예은", "강다현"]
```

🖨️ 출력 결과:
```python
원본: ['김민수', '이수정', '박지훈', '최예은', '강다현']
정렬된: ['강다현', '김민수', '박지훈', '이수정', '최예은']
```

✅ 정답 코드:
```python
students = ["김민수", "이수정", "박지훈", "최예은", "강다현"]
sorted_students = sorted(students)

print("원본:", students)
print("정렬된:", sorted_students)
```

🔍 **해설**:
- `sorted()`는 원본 유지 + 새 정렬 리스트 반환
- 한글은 유니코드 기준으로 자동 가나다순 정렬됨

