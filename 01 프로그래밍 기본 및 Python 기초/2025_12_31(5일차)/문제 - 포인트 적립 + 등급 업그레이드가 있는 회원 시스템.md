프로젝트 코드명: `PointClub-TDD`
프로젝트 유형: 콘솔 기반 비즈니스 로직 + 단위 테스트(TDD 연습)


🖥️ 프로젝트 개요
	쇼핑몰/서비스에서 자주 사용하는 회원 포인트 시스템을 직접 구현해보는 미니 프로젝트입니다.

- 회원을 등록하고,
- 결제 금액을 반영해서 포인트를 적립하고,
- 누적 금액에 따라 등급(VIP, VVIP) 을 자동으로 올려주는 로직을 구현합니다.
- 이 모든 기능을 단위 테스트 + TDD 흐름(Red → Green → Refactor)으로 연습하는 것이 목적입니다.

---
###### 📚 이 프로젝트를 통해 자연스럽게 적용되는 내용
| 항목    | 내용                                                   |
| ----- | ---------------------------------------------------- |
| 자료형   | dict, list, int, str 다루기                             |
| 제어문   | if / elif / else, 비교 연산                              |
| 반복문   | 회원 목록(리스트)에서 회원 찾기                                   |
| 함수    | 입력/출력이 명확한 순수 함수 설계                                  |
| 모듈 분리 | `point_club.py` (로직) / `test_point_club.py` (테스트) 분리 |
| 예외 처리 | 잘못된 입력값에 대해 `ValueError` 발생시키기                       |
| TDD   | 실패하는 테스트 먼저 작성 → 최소 구현 → 리팩토링                        |

---
###### 📄 기능 요구사항 (Functional Requirements)
| 기능ID | 기능설명     | 세부내용                                                                                                                         |
| ---- | -------- | ---------------------------------------------------------------------------------------------------------------------------- |
| F-01 | 회원 등록    | `add_member(members, name)` : 새 회원을 등록한다. 초기 등급은 `"BASIC"`, `total_spent = 0`, `points = 0` 으로 시작한다. 이름이 비어 있으면 `ValueError` |
| F-02 | 회원 조회    | `find_member(members, name)` : 이름으로 회원 dict를 찾아 반환한다. 없으면 `None` 반환                                                          |
| F-03 | 결제 반영    | `add_purchase(members, name, amount)` : 해당 회원의 결제 금액을 반영한다. `amount`가 0 이하이면 `ValueError`                                    |
| F-04 | 포인트 적립   | 결제 시 등급에 따라 포인트를 적립한다. BASIC=1%, VIP=2%, VVIP=3% (반올림, 정수 포인트)                                                               |
| F-05 | 등급 업그레이드 | `update_grade(member)` : `total_spent` 기준으로 자동 등급 조정. 50만 원 이상 → `VIP`, 100만 원 이상 → `VVIP`                                   |
| F-06 | 회원 요약 조회 | `get_member_summary(member)` : `"이름/등급/누적금액/포인트"` 를 문자열로 만들어 반환한다. 예: `"홍길동(BASIC) - 누적: 150000원, 포인트: 1500점"`               |

---
###### 📄 비기능 요구사항 (Non-Functional Requirements)
| 항목       | 설명                                                                                        |
| -------- | ----------------------------------------------------------------------------------------- |
| 코드 구조    | 회원 관련 로직은 모두 `point_club.py` 에 작성하고, 테스트는 `test_point_club.py` 에 분리한다.                    |
| 테스트 커버리지 | 위 기능ID(F-01 ~ F-06)에 해당하는 핵심 로직은 모두 `unittest` 기반 테스트를 최소 1개 이상 가져야 한다.                   |
| 가독성      | 함수 이름, 변수 이름을 의미 있게 짓고, 각 함수에 간단한 docstring 한 줄 이상 작성한다.                                  |
| 확장 가능성   | 이후에 “등급별 추가 혜택” 등을 붙일 수 있도록, 등급/포인트 로직을 한 군데로 모아둔다(하드코딩은 하되, 나중에 바꾸기 쉽게).                 |
| 에러 처리    | 이름이 비어 있음, 금액이 0 이하인 경우, 존재하지 않는 회원에 대한 결제 요청 등은 `ValueError` 또는 `None` 반환 등으로 깔끔하게 처리한다. |

---

✅ 출력 포맷 구성1
	이번 프로젝트의 “눈으로 확인하는” 출력은 두 가지입니다.

테스트 실행 결과
```bash
python test_point_club.py
```

예상 출력(모든 테스트 통과 시):
```
......
----------------------------------------------------------------------
Ran 6 tests in 0.000s

OK
```

간단한 수동 실행용 예시 (선택, main 함수 안에서)
```
=== 회원 요약 ===
홍길동(BASIC) - 누적: 150000원, 포인트: 1500점
김영희(VIP)   - 누적: 600000원, 포인트: 12000점
```

👉 핵심은 테스트 코드로 자동 검증하는 것이고, 수동 실행은 “보너스”라고 생각하면 됩니다.

---

✅ 정답 코드
스스로 먼저 도전해보고, 그다음 아래 코드를 비교하면서 “아 이런 흐름이구나” 보는 용도로 사용하면 좋아요.

추천 디렉터리 구조
```
point_club/
│
├── app_console.py           # 콘솔(UI/흐름) — presentation layer
│
├── core/                    # 💡 핵심 도메인(비즈니스 규칙)
│   ├── __init__.py
│   ├── models.py            # 데이터 구조 정의
│   ├── rules.py             # 정책/상수 (포인트율, 등급 기준)
│   ├── repository.py        # 데이터 저장소 (in-memory / 추후 DB로 교체 가능)
│   └── services.py          # 핵심 기능(비즈니스 로직)
│
└── tests/
    └── test_services.py     # 단위 테스트 (TDD 대상)
```

- UI / 흐름 → `app_console.py`
- 도메인 규칙 → `core/`
- 저장 방식 → `repository.py` (DB로 바꾸기 쉽게)
- 정책/상수 → `rules.py`
- 테스트 → `tests/`

---
1️⃣ core/rules.py — 정책 & 상수만 분리
```python
"""
core/rules.py

👉 이 파일은 '규칙(Policy)'만 모아두는 곳입니다.

- 등급 기준
- 포인트 적립률

같은 "비즈니스 정책"은
여러 함수/모듈에서 동시에 사용됩니다.

그래서 여기서 한 번만 정의해두면:

    ✔ 나중에 정책이 바뀌었을 때
       → 이 파일만 수정하면 전체 기능이 함께 바뀐다.

    ✔ 서비스 로직(services.py)이
       정책 숫자에 직접 의존하지 않게 되어,
       코드가 훨씬 읽기 쉽고 유지보수하기 쉬워진다.
"""

# ----------------------------------------------------------
# 🥇 등급 기준값 정의
# ----------------------------------------------------------
# 누적 결제 금액(total_spent)이
# 일정 금액을 넘으면 회원 등급을 올려 줍니다.
#
# 예)
#   - 500,000원 이상이면 VIP
#   - 1,000,000원 이상이면 VVIP
#
# 숫자만 보면 의미를 알기 힘드니까,
# 의미 있는 상수 이름으로 분리했습니다.
# ----------------------------------------------------------

VIP_THRESHOLD = 500_000      # VIP가 되는 최소 누적 금액
VVIP_THRESHOLD = 1_000_000   # VVIP가 되는 최소 누적 금액


# ----------------------------------------------------------
# 🎁 포인트 적립률 정의
# ----------------------------------------------------------
# 회원 등급에 따라 포인트 적립률이 달라집니다.
#
#   BASIC → 1%
#   VIP   → 2%
#   VVIP  → 3%
#
# 딕셔너리를 사용해서
#   POINT_RATES["VIP"] == 0.02
# 처럼 쉽게 조회할 수 있게 만들었습니다.
#
# (💡 장점)
#   - 서비스 로직에서 if/elif를 길게 쓰지 않아도 되고,
#   - 새로운 등급이 생겨도 여기 한 줄 추가하면 끝!
# ----------------------------------------------------------

POINT_RATES = {
    "BASIC": 0.01,   # 기본 회원: 결제금액의 1% 적립
    "VIP": 0.02,     # VIP 회원: 결제금액의 2% 적립
    "VVIP": 0.03,    # VVIP 회원: 결제금액의 3% 적립
}
```
👉 정책이 바뀌면 여기만 수정!

---

2️⃣ core/models.py — 데이터 구조 정의
```python
"""
core/models.py

👉 이 파일은 "데이터 모양(구조)"만 정의하는 곳입니다.

여기서는 회원(Member)이 어떤 정보를 가지고 있는지,
즉 **이름, 등급, 누적 결제 금액, 포인트** 같은 속성을 정의합니다.

💡 핵심 포인트
- '어떤 데이터를 다룰 것인지'를 먼저 정리해 두면
  나중에 기능(services.py)을 설계할 때 훨씬 쉬워집니다.
- 데이터 구조만 따로 분리해 두면
  코드가 "명사(데이터)" / "동사(기능)"로 깔끔하게 나뉩니다.
"""

# dataclass는 "데이터만 가지는 클래스"를 편하게 만들어주는 도구입니다.
# - 자동으로 __init__, __repr__ 같은 메서드를 만들어 줍니다.
# - 우리가 저장하고 싶은 필드(변수)만 선언하면 됩니다.
from dataclasses import dataclass


@dataclass
class Member:
    """
    👉 포인트 클럽의 '회원' 1명을 표현하는 데이터 구조

    이 클래스는 "어떤 데이터를 들고 다닐지"만 정의합니다.
    실제로 등급을 바꾸거나 포인트를 계산하는 기능은
    core/services.py 쪽에서 처리하고,
    여기는 오직 "필드 정의"에만 집중합니다.

    필드 설명:
        - name: 회원 이름 (예: "홍길동")
        - grade: 회원 등급 (기본값: "BASIC")
            * "BASIC", "VIP", "VVIP" 등
        - total_spent: 누적 결제 금액 (int, 기본 0)
        - points: 누적 적립 포인트 (int, 기본 0)
    """

    # 회원 이름 (반드시 필요하므로 기본값 없음)
    name: str

    # 회원 등급
    # 기본값을 "BASIC"으로 두면,
    # Member(name="홍길동") 이렇게만 생성해도
    # grade는 자동으로 "BASIC"으로 들어갑니다.
    grade: str = "BASIC"

    # 누적 결제 금액
    # 처음 가입했을 때는 아직 결제 내역이 없으므로 0원부터 시작합니다.
    total_spent: int = 0

    # 누적 포인트
    # 처음 가입 시에는 포인트도 0점입니다.
    points: int = 0
```
👉 dict 대신 dataclass → 가독성 + 타입 안정성

---
3️⃣ core/repository.py — 저장소(추후 DB 교체 가능)
```python
"""
core/repository.py

👉 이 파일은 **데이터를 보관하고 찾는 역할(저장소, Repository)** 만 담당합니다.

⚠️ 중요한 개념

- models.py  :  "데이터 모양(구조)" 정의 (Member가 어떤 정보를 가지는가?)
- repository.py : "데이터를 어디에, 어떻게 보관할 것인가?"

지금은 아직 데이터베이스(DB)를 쓰지 않아서
👉 "메모리(List)에 저장"하는 방식으로 구현합니다.

하지만 나중에:

- SQLite / MySQL / PostgreSQL 로 바꾸더라도
- 이 파일만 수정하면 전체 코드 흐름은 그대로 유지됩니다.

즉,
> 💡 Repository 는 “데이터 접근 전담 창구” 역할을 합니다.
"""

from typing import List, Optional
from .models import Member


class MemberRepository:
    """
    👉 회원 데이터를 관리하는 저장소 클래스

    하는 일:
      - 회원 목록을 보관한다.
      - 회원을 추가한다.
      - 회원 전체 목록을 반환한다.
      - 이름으로 회원을 검색한다.

    지금은 단순히 `self.members` 리스트에 담지만,
    구조를 이렇게 분리해 두면 —> 나중에 DB로 바꿔 달기 쉽습니다.
    """

    def __init__(self):
        """
        Repository를 생성하면,
        내부적으로 '회원 리스트'를 하나 가지고 시작합니다.

        현재 구조:
            self.members = []
        """
        self.members: List[Member] = []

    def add(self, member: Member) -> None:
        """
        👉 새로운 회원을 저장소에 추가한다.

        매개변수:
            - member : Member 객체 (models.Member)

        동작:
            단순히 리스트에 append 한다.
        """
        self.members.append(member)

    def all(self) -> List[Member]:
        """
        👉 저장된 모든 회원을 리스트 형태로 반환한다.

        사용 예:
            repo = MemberRepository()
            repo.all()   --> [Member(...), Member(...)]
        """
        return self.members

    def find(self, name: str) -> Optional[Member]:
        """
        👉 이름으로 회원 1명을 찾아 반환한다.

        동작:
            - members 리스트를 순회하며
            - name이 같은 Member를 찾는다.
            - 찾으면 Member 객체를 반환
            - 없으면 None 반환

        next(...) 표현식 설명:
            next( generator , 기본값 )

            → 조건에 맞는 첫 번째 값을 찾고, 없으면 기본값 반환
        """
        return next((m for m in self.members if m.name == name), None)
```

---
4️⃣ core/services.py — 핵심 비즈니스 로직
```python
"""
core/services.py

👉 이 파일은 **비즈니스 로직(실제 규칙이 동작하는 곳)** 을 담당합니다.

구조를 다시 정리해 보면:

- models.py        → 데이터 구조 정의 (Member가 어떤 필드를 가지는가?)
- repository.py    → 데이터를 보관/조회 (메모리, 나중에는 DB)
- rules.py         → 숫자/기준 같은 "규칙 값"
- services.py      → 실제 기능(로직) 실행

즉, 여기서 하는 일은:

  ✔ 회원 추가
  ✔ 회원 등급 갱신
  ✔ 결제 처리 (포인트 적립 + 등급 조정)
  ✔ 회원 요약 정보 생성

> 💡 services.py는 “현실 규칙을 코드로 구현한 층”이라고 이해하면 됩니다.
"""

from .models import Member
from .rules import VIP_THRESHOLD, VVIP_THRESHOLD, POINT_RATES
from .repository import MemberRepository


def add_member(repo: MemberRepository, name: str) -> None:
    """
    👉 새 회원을 등록하는 기능

    동작 순서:
      1) 이름이 비었는지 확인
      2) 이미 같은 이름이 있는지 확인
      3) 없으면 Member 객체를 만들어 저장소(repo)에 추가

    왜 repo를 매개변수로 받나?
      → services는 "데이터를 어디에 저장하는지"에 관심이 없고,
        그냥 repo에게 맡기기 위함 (의존성 분리).
    """
    if not name.strip():
        raise ValueError("이름은 비어 있을 수 없습니다.")

    if repo.find(name):
        raise ValueError("이미 존재하는 회원입니다.")

    # Member 객체 생성 후 저장소에 추가
    repo.add(Member(name=name.strip()))


def update_grade(member: Member) -> None:
    """
    👉 회원의 누적 결제 금액(total_spent)에 따라 등급을 바꾼다.

    규칙:
        - 100만 이상  → VVIP
        - 50만 이상   → VIP
        - 나머지      → BASIC
    """
    if member.total_spent >= VVIP_THRESHOLD:
        member.grade = "VVIP"
    elif member.total_spent >= VIP_THRESHOLD:
        member.grade = "VIP"
    else:
        member.grade = "BASIC"


def add_purchase(repo: MemberRepository, name: str, amount: int) -> None:
    """
    👉 결제가 발생했을 때 처리하는 핵심 기능

    동작 순서:
      1) 금액 유효성 검사
      2) 회원 찾기 (없으면 오류)
      3) 누적 결제 금액에 추가
      4) 현재 등급 기준으로 포인트 적립
      5) 누적 금액 기준으로 등급 다시 계산

    여기서 중요한 포인트:

    - 포인트 적립은 "결제 당시 등급" 기준
    - 등급 변경은 결제 후에 일어남
    """
    if amount <= 0:
        raise ValueError("결제 금액은 0보다 커야 합니다.")

    member = repo.find(name)
    if not member:
        raise ValueError("존재하지 않는 회원입니다.")

    # 1️⃣ 누적 금액 업데이트
    member.total_spent += amount

    # 2️⃣ 포인트 적립 (등급 → 포인트 비율 가져오기)
    rate = POINT_RATES[member.grade]
    member.points += round(amount * rate)

    # 3️⃣ 결제 후, 누적 금액 기준으로 등급 갱신
    update_grade(member)


def get_summary(member: Member) -> str:
    """
    👉 회원 정보를 사람이 읽기 쉬운 문자열로 변환

    예)
      Input :
        Member(name="홍길동", grade="VIP", total_spent=600000, points=8000)

      Output :
        "홍길동(VIP) - 누적: 600000원, 포인트: 8000점"

    UI/출력 쪽에서 사용할 데이터 포맷을 만들어주는 역할.
    """
    return (
        f"{member.name}({member.grade}) "
        f"- 누적: {member.total_spent}원, 포인트: {member.points}점"
    )
```
👉 UI 한 줄도 없음.  
👉 오직 비즈니스 규칙만.

---
5️⃣ app_console.py — 콘솔 UI 전용
```python
"""
app_console.py

👉 이 파일은 **콘솔(터미널)에서 실행되는 "입·출력 담당" 프로그램**입니다.

역할 정리:

- core/models.py        → Member 데이터 구조
- core/rules.py         → 등급/포인트 규칙 숫자
- core/repository.py    → Member 저장소 (메모리 리스트)
- core/services.py      → 비즈니스 로직 (회원 추가, 결제, 등급 변경, 요약)
- app_console.py        → 사용자와 직접 대화(입력/출력), 메뉴/흐름 제어

즉, 이 파일은
"유저가 키보드로 입력 → 어떤 서비스 함수를 호출할지 결정 → 결과를 프린트"
하는 **컨트롤러 / 진입점** 역할을 합니다.
"""

from core.repository import MemberRepository
from core.services import add_member, add_purchase, get_summary


def menu() -> None:
    """
    👉 콘솔에 메인 메뉴를 출력하는 함수.

    - 실제로 아무 로직을 수행하지 않고, "화면 구성"만 담당합니다.
    - 이렇게 메뉴 출력을 함수로 빼두면,
      나중에 메뉴 구성이 바뀌어도 이 함수만 고치면 됩니다.
    """
    print("\n=== PointClub ===")
    print("1) 회원 추가")
    print("2) 결제 추가")
    print("3) 회원 목록 보기")
    print("0) 종료")


def main() -> None:
    """
    👉 프로그램의 '시작점'이자 전체 흐름을 제어하는 함수.

    주요 역할:
      1) MemberRepository 생성
         → 회원 데이터를 메모리에 보관할 저장소 준비
      2) 무한 루프(while True)로 메뉴를 반복해서 보여줌
      3) 사용자의 입력(choice)에 따라
         → 알맞은 서비스 함수(add_member, add_purchase 등)를 호출
      4) '0'을 입력하면 프로그램 종료
    """

    # 1) 회원 저장소 생성
    #    - 이 repo가 프로그램이 실행되는 동안
    #      모든 회원 정보를 가지고 있게 됩니다.
    repo = MemberRepository()

    # 2) 무한 반복으로 메뉴 → 선택 → 기능 실행
    while True:
        # 메뉴 출력
        menu()

        # 메뉴 번호 입력 받기 (문자열로 받은 뒤 공백 제거)
        choice = input("선택: ").strip()

        # --------------------------------------------------
        # 1) 회원 추가
        # --------------------------------------------------
        if choice == "1":
            # 회원 이름 입력
            name = input("이름: ")

            try:
                # 서비스 레이어에 "회원 추가"를 요청
                add_member(repo, name)
                print("✅ 회원 등록 완료")
            except ValueError as e:
                # 잘못된 입력(공백, 중복 이름 등)은
                # 서비스에서 ValueError로 알려주고,
                # 여기서는 메시지만 사용자에게 출력
                print("⚠️ 오류:", e)

        # --------------------------------------------------
        # 2) 결제 추가
        # --------------------------------------------------
        elif choice == "2":
            # 결제할 회원 이름과 금액 입력
            name = input("회원 이름: ")
            raw_amount = input("결제 금액: ")

            # 숫자 아닌 값이 들어왔을 때 대비
            if not raw_amount.isdigit():
                print("⚠️ 결제 금액은 숫자로 입력해주세요.")
                continue

            amount = int(raw_amount)

            try:
                # 서비스 레이어에 "결제 반영" 요청
                #   - 누적 결제 금액 증가
                #   - 포인트 적립
                #   - 등급 재계산
                add_purchase(repo, name, amount)
                print("✅ 결제 반영 완료")
            except ValueError as e:
                # 존재하지 않는 회원, 0원 이하 금액 등
                # 비즈니스 로직에서 발생한 문제를 메시지로 출력
                print("⚠️ 오류:", e)

        # --------------------------------------------------
        # 3) 회원 목록 보기
        # --------------------------------------------------
        elif choice == "3":
            # 저장소(repo)에 있는 모든 회원을 가져와서
            # 각 회원에 대해 요약 문자열(get_summary)을 출력
            if not repo.all():
                print("ℹ️ 아직 등록된 회원이 없습니다.")
            else:
                print("\n--- 회원 목록 ---")
                for m in repo.all():
                    print(get_summary(m))

        # --------------------------------------------------
        # 0) 프로그램 종료
        # --------------------------------------------------
        elif choice == "0":
            print("프로그램을 종료합니다. 👋")
            break  # while True 루프 탈출 → main() 종료 → 프로그램 끝

        # --------------------------------------------------
        # 그 외: 잘못된 입력 처리
        # --------------------------------------------------
        else:
            print("❌ 잘못된 입력입니다. 0~3 중에서 선택해주세요.")


# 이 파일을 '직접 실행'했을 때만 main()을 호출
#   - python app_console.py  → main() 실행
#   - 다른 파일에서 import app_console 할 때는 main()이 자동 실행되지 않음
if __name__ == "__main__":
    main()
```

---

`test_point_club.py` (단위 테스트 코드 – TDD용)
```python
"""
test_point_club.py

👉 목적:
    - point_club.py 안의 함수들이
      우리가 의도한 대로 잘 동작하는지 자동으로 확인한다.

👉 핵심 개념:
    - 테스트 코드 = "스스로 실행되는 확인 체크리스트"
    - 코드가 수정되거나 기능이 늘어나도
      여기 테스트를 돌리면, 깨진 부분을 바로 알 수 있다.

실행 방법:
    python test_point_club.py
"""

import unittest

# 테스트 대상 함수들 가져오기
from point_club import (
    add_member,
    find_member,
    add_purchase,
    calc_point,
    update_grade,
    get_member_summary,
)


class TestPointClub(unittest.TestCase):
    """
    unittest.TestCase 를 상속받으면
    이 클래스 안의 'test_' 로 시작하는 함수들이
    모두 자동으로 테스트로 인식된다.
    """

    def test_add_member_basic_info(self):
        """
        [테스트 목적]
        - 새 회원을 추가하면,
          기본 정보가 정확하게 초기화되는지 확인한다.
        """

        members = []             # 빈 회원 리스트 준비
        add_member(members, "홍길동")   # 회원 1명 추가

        # 1명 추가되었는지 확인
        self.assertEqual(len(members), 1)

        member = members[0]

        # 추가된 회원의 기본값이 정확한가?
        self.assertEqual(member["name"], "홍길동")
        self.assertEqual(member["grade"], "BASIC")      # 기본 등급
        self.assertEqual(member["total_spent"], 0)      # 누적 금액 0
        self.assertEqual(member["points"], 0)           # 포인트 0

    def test_add_member_empty_name_raises(self):
        """
        [테스트 목적]
        - 이름이 비어 있을 경우, 회원 등록이 실패해야 한다.
        - 실패 = ValueError 예외가 발생해야 정상!
        """

        members = []

        # add_member 호출 시 예외가 터지는지 확인
        with self.assertRaises(ValueError):
            add_member(members, "   ")    # 공백만 있는 이름

    def test_find_member(self):
        """
        [테스트 목적]
        - 등록된 회원은 검색 시 찾아져야 하고,
        - 없는 회원은 None 이 나와야 한다.
        """

        members = []
        add_member(members, "홍길동")

        # 존재하는 회원 찾기
        result = find_member(members, "홍길동")
        self.assertIsNotNone(result)
        self.assertEqual(result["name"], "홍길동")

        # 존재하지 않는 회원은 None 이어야 한다
        none_result = find_member(members, "아무개")
        self.assertIsNone(none_result)

    def test_calc_point_by_grade(self):
        """
        [테스트 목적]
        - 등급별 포인트 계산이 정확한지 확인한다.
        """

        # BASIC = 1%
        self.assertEqual(calc_point("BASIC", 100_000), 1000)

        # VIP = 2%
        self.assertEqual(calc_point("VIP", 100_000), 2000)

        # VVIP = 3%
        self.assertEqual(calc_point("VVIP", 100_000), 3000)

    def test_add_purchase_and_update_grade(self):
        """
        [테스트 목적]
        - 결제 금액을 추가하면:
            1) 누적 금액(total_spent)이 증가하고
            2) 포인트가 적립되고
            3) 누적 금액 기준으로 등급이 자동으로 변경되는지 확인한다.
        """

        members = []
        add_member(members, "김영희")
        member = find_member(members, "김영희")

        # 첫 결제: 300,000원 → VIP 기준(500,000) 미만
        add_purchase(members, "김영희", 300_000)

        # 누적 금액이 30만 원이 되었는가?
        self.assertEqual(member["total_spent"], 300_000)

        # BASIC 등급에서는 1% 포인트 적립 → 3000점
        self.assertEqual(member["points"], 3000)

        # 아직 등급은 BASIC이어야 한다
        self.assertEqual(member["grade"], "BASIC")

        # 두 번째 결제: 300,000원 → 누적 600,000원 → VIP 승급!
        add_purchase(members, "김영희", 300_000)

        # 누적 금액 확인
        self.assertEqual(member["total_spent"], 600_000)

        # 두 번째 결제 때도 BASIC 상태였으므로 1% 적립
        # 총 포인트 = 3000 + 3000 = 6000
        self.assertEqual(member["points"], 6000)

        # 이제 등급이 VIP로 바뀌어야 한다
        self.assertEqual(member["grade"], "VIP")

    def test_add_purchase_invalid_member_raises(self):
        """
        [테스트 목적]
        - 존재하지 않는 회원에 대해 결제 추가를 시도할 경우,
          반드시 ValueError가 발생해야 한다.
        """

        members = []

        with self.assertRaises(ValueError):
            add_purchase(members, "없는사람", 10_000)

    def test_get_member_summary_format(self):
        """
        [테스트 목적]
        - 요약 문자열이 정상적으로 만들어지는지,
          최소한 중요한 값들이 포함되어 있는지 확인한다.
        """

        members = []
        add_member(members, "홍길동")
        member = find_member(members, "홍길동")

        add_purchase(members, "홍길동", 150_000)

        summary = get_member_summary(member)

        # 문자열 안에 필요한 정보가 모두 포함되어 있는가?
        self.assertIn("홍길동", summary)
        self.assertIn("BASIC", summary)
        self.assertIn("150000", summary)
        self.assertIn("1500", summary)


# 💡 이 파일을 직접 실행했을 때만 테스트 수행
if __name__ == "__main__":
    unittest.main()
```
---
`1.` 무조건 테스트해야 하는 것 4가지(최우선)

`1)` 돈 / 포인트 / 재고 / 점수처럼 **숫자 계산**이 들어가는 로직
- 예:
    - 결제 금액 → 할인 → 최종 금액
    - 누적 결제 금액 → 포인트
    - 시험 점수 리스트 → 평균 / 등급
- 이유:
    - 한 줄만 잘못 계산해도 돈/점수/포인트가 틀어짐 = 큰 사고
    - 입력이 좀만 바뀌어도 결과가 바뀌니까 테스트로 고정해두는 게 좋음

👉 기준
- “이 값이 잘못되면 돈이 틀어지거나, 결과가 엄청 이상해진다” → 무조건 테스트

---
`2)` 조건문/분기(if/elif)로 케이스가 나뉘는 곳

예:
```python
if total >=1000000:
    grade ="VVIP"
elif total >=500000:
    grade ="VIP"
else:
    grade ="BASIC"
```

👉 기준
- if/elif/else로 나눠진 **각 케이스마다 최소 1개씩 테스트**
    - BASIC 구간
    - VIP 구간
    - VVIP 구간

→ 이렇게 안 하면, 어느 한 쪽은 평생 안 돌아본 코드가 될 수 있음.

---
`3)` 입력 검증(Validation) & 예외 처리가 있는 곳

예:
```python
if amount <= 0:
    raise ValueError("결제 금액은 0보다 커야 합니다.")
```

이런 코드가 있으면 테스트 2개를 떠올리면 좋아요:
1. 정상 입력 → 예외 없이 잘 동작하는지
2. 잘못된 입력 → 진짜로 `ValueError`가 나는지

👉 기준
- `raise ValueError(...)`, `raise Exception(...)` 같은 코드가 있다
    → 그 줄을 꼭 테스트로 한 번 때려본다.
    
---
`4)` 버그가 한 번이라도 났던 부분
- 현실 기준으로 제일 중요한 기준입니다.
- “여기서 한 번 사고가 났었다” 싶은 부분은
    → 그 버그를 재현하는 테스트 + 고친 후 통과하는 테스트를 반드시 남겨야 함.
    
👉 기준
- 내가/팀이 “여기서 예전에 에러났었지…” 기억하는 부분 → **테스트로 박제**
이게 바로 회귀 테스트(regression test) 개념이에요.

---
`2.` 초보자용 “테스트 설계 순서”
기능 하나당, 이 3단계만 해도 충분히 잘하는 거예요.

Step 1) 정상 흐름 먼저
- 가장 일반적인 사용 시나리오 1개
- 예: `add_member`면
    - 정상 이름 → 잘 추가되는지
- 예: `discount_price`면
    - 10,000원 / 10% → 9,000원 나오는지
> “이 기능이 보통 어떻게 쓰일까?” → 그걸 1개 테스트로 먼저 고정
---
Step 2) 경계값(바로 걸쳐 있는 값)
조건문이 있다면, 그 경계 주변 값은 꼭 테스트해야 합니다.

예:
`if total >= 500000: VIP`
- 499,999원 → VIP가 아니어야 함
- 500,000원 → VIP여야 함

할인율 0 ~ 100 사이 규칙이라면:
- 0, 1, 99, 100 → 정상
- 1, 101 → 예외

👉 기준
- `>=`, `>`, `<`, `<=` 이런 게 나오면
    → 그 숫자를 기준으로 바로 앞/뒤 값까지 묶어서 생각
    
---
Step 3) 잘못된 입력 / 예외 케이스

예:
```python
def add_member(name):
    if not name.strip():
        raise ValueError
```

테스트:
- `"홍길동"` → OK
- `" "` → `ValueError` 발생

👉 기준
- “사용자가 이렇게도 입력할 수 있겠다” 싶은 **이상한 입력**을 한두 개 골라서
    → 진짜로 막히는지 테스트.
    
---
`3.` “무조건 다 테스트해야 되는 건 아님” (초보자용 제외 리스트)

`1)` 단순 프린트/메뉴 출력만 하는 코드
예:
```python
def menu():
    print("1) 회원 추가")
    print("2) 결제 추가")
```

- 이런 건 **화면 모양만 바뀌는 부분이라, 굳이 테스트 안 해도 됨**
- 눈으로 한 번 돌려보면서 확인하는 걸로 충분

👉 기준
- “이 함수는 계산/로직 없이 그냥 print만 잔뜩이다”
    → 테스트 없어도 괜찮다 (초보 단계에서는 신경 안 써도 됨)
    
---
`2)` 단순 위임 함수 (로직 없이 넘겨주기만 하는 경우)

예:
```python
def get_summary(member: Member) -> str:
    return f"{member.name}({member.grade}) - ..."
```

- 여기 안에서 복잡한 계산/조건이 없다면
- 나중에 틀려도 그냥 문자열 포맷 조금 수정하면 되는 수준

👉 기준
- “틀려도 치명적이지 않고, 쉽게 눈으로 확인 가능하다” → 우선순위 낮음

(그래도 짧은 테스트 하나 추가해두면 물론 좋긴 함)

---
`4.` 초보자용 “테스트 우선순위 체크리스트”

새 기능 만들 때, 아래 순서대로 자문해보면 좋아요 👇
1. 이 기능이 돈/포인트/점수/재고를 바꾸나?
    - YES → 테스트 무조건
2. if/elif/else로 분기 나뉘는가?
    - YES → 각 분기마다 최소 1개
3. `raise`로 예외를 던지는 코드가 있는가?
    - YES → 정상/에러 케이스 모두 테스트
4. 버그가 한 번이라도 나왔던 코든가?
    - YES → 그 버그를 재현하는 테스트 꼭 작성
5. 나중에 로직이 자주 바뀔 것 같은가?
    - YES → 테스트 있으면 바꿀 때 마음이 편함

이 5가지에 걸리면:
👉 “이건 테스트를 써야 하는 애구나” 라고 생각하시면 됩니다.

---
`5.` 아주 구체적인 예시 (PointClub 기준)
예를 들어 지금 만든 PointClub에서…

반드시 테스트해야 하는 것
- `calc_point(grade, amount)`
    - 등급별 포인트 계산 (돈/비즈니스 규칙)
- `update_grade(member)`
    - 누적 금액에 따른 등급 변경 (조건/경계값)
- `add_purchase(repo, name, amount)`
    - 결제 → 누적 금액 증가 + 포인트 적립 + 등급 갱신
    - 잘못된 금액 / 없는 회원 예외

“있으면 좋은” 정도의 테스트
- `add_member(repo, name)`
    - 정상 추가 + 중복/공백 예외
- `get_summary(member)`
    - 문자열에 중요한 정보가 들어 있는지

굳이 안 해도 되는 것(초보 단계 기준)
- `menu()`의 출력 문자열
- `app_console.py`에서 `input()` + `print()` 조합
    - 이건 그냥 실제로 실행해서 눈으로 보는 게 더 빠름

---
`6.` 한 줄 요약
반드시 테스트해야 하는 기준은
➜ “돈/포인트/등급/재고 같은 중요한 숫자 계산”
➜ “if/elif 분기, 경계값 근처”
➜ “예외(raise)가 있는 곳”
➜ “한 번이라도 사고났던 코드”
이 네 가지고, 그 외에 화면 출력/단순 프린트는 처음엔 과감하게 빼도 괜찮아요.