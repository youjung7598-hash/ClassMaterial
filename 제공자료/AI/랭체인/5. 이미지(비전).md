종류 예시:
- 이미지를 업로드 하면 칼로리를 자동으로 계산해 주는 앱
- 스마트 영수증 분석 챗봇
    - 사용자가 영수증 사진을 올리면 LangChain이 OpenAI Vision 모델로 금액·상품·날짜를 추출 → 지출 내역을 DB에 저장 → 이번 달 지출 통계 같은 질의응답 가능.
        
- 실시간 안전 모니터링 도우미
    - CCTV/사진 속에서 화재, 연기, 위험 표지판 여부를 Vision 모델이 판별 → LangChain이 이를 상황 설명으로 정리 → 경고 메시지나 Slack/카톡 알림 전송.
        
- 이미지 기반 여행 가이드 챗봇
    - 사용자가 명소 사진을 업로드 → Vision 모델이 건물/풍경을 인식 → LangChain이 관련 역사·위치·추천 코스 정보를 검색 후 답변.

---
##### 이미지를 업로드 하면 칼로리를 자동으로 계산해 주는 앱

업로드한 스크린샷 1장(+선택 메모)을 기반으로  
증상 요약, 재현 절차(Steps), 예상/실제 결과, 심각도(severity), 환경, 원인 추정, 수정 제안을 자동 생성

`0)` 새 프로젝트 & 설치
```bash
mkdir bug-report-assistant && cd bug-report-assistant

# (선택) 가상환경
python -m venv .venv && source .venv/bin/activate  # Windows: .venv\Scripts\activate

# 필수 패키지
pip install fastapi uvicorn python-dotenv langchain==0.1.10 langchain-openai
```

`.env`
```env
OPENAI_API_KEY=sk-...
OPENAI_MODEL=gpt-4o-mini      # 비전+텍스트 모델
```

`1)` 디렉토리 구조
```
calorie-bot/
├─ app/
│  ├─ main.py
│  ├─ api/
│  │   └─ calorie_routes.py
│  └─ services/
│      └─ calorie_estimator.py
└─ web/
   └─ calorie.html
```

`2)` 서비스 로직 — 음식 인식 + 칼로리 계산
`app/services/calorie_estimator.py`
```python
import os, base64, difflib
from typing import List, Optional, Dict, Any
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.messages import HumanMessage
from langchain_core.pydantic_v1 import BaseModel, Field

load_dotenv()
MODEL = os.getenv("OPENAI_MODEL", "gpt-4o-mini")

# (아주 간단한) 내부 영양 테이블: 100g 기준 kcal
# 실무에선 DB/CSV(USDA 등)를 붙이세요.
NUTRITION_KCAL_100G = {
    "rice": 130, "white rice": 130, "brown rice": 111, "bibimbap": 155,
    "noodles": 138, "ramen": 460, "pasta": 157,
    "fried chicken": 260, "chicken breast": 165, "bulgogi": 215, "pork belly": 518,
    "kimchi": 15, "lettuce": 15, "salad": 80, "egg": 155,
    "banana": 89, "apple": 52, "strawberry": 32,
    "pizza": 266, "hamburger": 250, "french fries": 312,
    "sushi": 130, "gimbap": 180, "tteokbokki": 175,
}

# 비전 LLM이 추출할 구조
class DetectedItem(BaseModel):
    name: str = Field(..., description="음식 이름(영문 또는 일반명)")
    portion_g: float = Field(..., description="대략적인 무게(그램)")

class VisionDetect(BaseModel):
    items: List[DetectedItem] = Field(default_factory=list)
    note_used: Optional[str] = None

SYS = (
    "You are a nutrition assistant. From the image and optional note, list visible foods "
    "and estimate portion size in grams per item for one serving. If unsure, omit the item."
)

def _to_data_url(image_bytes: bytes, mime: str) -> str:
    b64 = base64.b64encode(image_bytes).decode("utf-8")
    return f"data:{mime};base64,{b64}"

def _closest_key(food: str) -> Optional[str]:
    if not food: return None
    keys = list(NUTRITION_KCAL_100G.keys())
    m = difflib.get_close_matches(food.lower(), keys, n=1, cutoff=0.6)
    return m[0] if m else None

def estimate_calories(image_bytes: bytes, mime: str, note: Optional[str] = None) -> Dict[str, Any]:
    """스크린샷 한 장 → 음식 인식+그램 추정 → 내부 테이블로 칼로리 계산"""
    data_url = _to_data_url(image_bytes, mime)
    llm = ChatOpenAI(model=MODEL, temperature=0.1)
    llm_struct = llm.with_structured_output(VisionDetect)

    parts = [
        {"type": "text", "text": SYS + (f"\n\nUser note: {note}" if note else "")},
        {"type": "image_url", "image_url": {"url": data_url}},
    ]
    msg = HumanMessage(content=parts)
    vision: VisionDetect = llm_struct.invoke([msg])

    items_out, total_kcal = [], 0.0
    for it in vision.items:
        key = _closest_key(it.name)
        kcal100 = NUTRITION_KCAL_100G.get(key) if key else None
        est_kcal = round((it.portion_g / 100.0) * kcal100, 1) if kcal100 else None
        if est_kcal is not None:
            total_kcal += est_kcal
        items_out.append({
            "name": it.name,
            "mapped": key, # 내부 테이블과 매칭된 이름(없을 수 있음)
            "portion_g": it.portion_g,
            "kcal_per_100g": kcal100,
            "calories_est": est_kcal,
        })

    return {
        "items": items_out,
        "total_calories_est": round(total_kcal, 1),
        "note_used": vision.note_used or (note or None),
        "disclaimer": "대략 추정치입니다. 실제와 다를 수 있어요.",
    }
```

`3)` API 라우터
`app/api/calorie_routes.py`
```python
import os, uuid
from fastapi import APIRouter, UploadFile, File, Form, HTTPException
from fastapi.responses import JSONResponse
from app.services.calorie_estimator import estimate_calories

router = APIRouter(prefix="/calorie", tags=["calorie"])

UPLOAD_DIR = os.getenv("UPLOAD_DIR", "uploads")
os.makedirs(UPLOAD_DIR, exist_ok=True)

@router.post("/estimate")
async def estimate(image: UploadFile = File(...), note: str = Form(None)):
    if not image.content_type or not image.content_type.startswith("image/"):
        raise HTTPException(400, "이미지 파일을 업로드하세요.")

    ext = os.path.splitext(image.filename or "")[1] or ".png"
    raw = await image.read()
    # (선택) 저장해두고 싶으면 경로를 응답에 넣어주세요.
    fname = f"img_{uuid.uuid4().hex}{ext}"
    path = os.path.join(UPLOAD_DIR, fname)
    with open(path, "wb") as f:
        f.write(raw)

    try:
        out = estimate_calories(raw, image.content_type, note)
        out["preview_url"] = f"/uploads/{fname}" # 프론트 미리보기용
        return JSONResponse(out)
    except Exception as e:
        raise HTTPException(500, f"분석 실패: {e}")
```

`4)` #FastAPI 앱
`app/main.py`
```python
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from fastapi.responses import RedirectResponse
from app.api.calorie_routes import router as calorie_router

app = FastAPI(title="Calorie Estimator (LangChain Vision)")
app.include_router(calorie_router)

# 정적/업로드 서빙
app.mount("/web", StaticFiles(directory="web", html=True), name="web")
app.mount("/uploads", StaticFiles(directory="uploads"), name="uploads")

@app.get("/")
def root():
    return RedirectResponse(url="/web/calorie.html")
```

`5)` 프론트 (업로드 → 결과 렌더)
`web/calorie.html`
```html
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>이미지 → 칼로리 추정</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-slate-50 text-slate-900">
  <div class="max-w-3xl mx-auto p-6">
    <h1 class="text-2xl font-bold mb-2">이미지 기반 칼로리 추정</h1>
    <p class="text-sm text-slate-600 mb-6">사진 속 음식을 인식하고 대략 칼로리를 계산합니다.</p>

    <section class="bg-white rounded-2xl shadow p-5 mb-5">
      <form id="form" class="space-y-4">
        <div>
          <label class="block text-sm font-medium mb-1">이미지</label>
          <input id="image" type="file" accept="image/*" class="w-full"/>
        </div>
        <div>
          <label class="block text-sm font-medium mb-1">메모(선택)</label>
          <input id="note" class="w-full border rounded-xl px-3 py-2" placeholder="예: 김밥+치킨, 1인분"/>
        </div>
        <button id="go" class="px-5 py-3 rounded-xl bg-blue-600 text-white hover:bg-blue-700">분석하기</button>
      </form>
    </section>

    <section id="previewSec" class="bg-white rounded-2xl shadow p-5 mb-4 hidden">
      <h2 class="text-lg font-semibold mb-2">미리보기</h2>
      <img id="preview" class="max-h-72 rounded-xl border"/>
    </section>

    <section id="result" class="bg-white rounded-2xl shadow p-5 hidden">
      <div class="flex items-center justify-between">
        <h2 class="text-lg font-semibold">결과</h2>
        <div id="total" class="text-lg font-bold"></div>
      </div>
      <p id="disc" class="text-xs text-slate-500 mt-1"></p>
      <div id="items" class="mt-3 space-y-2"></div>
    </section>
  </div>

  <script>
    const form = document.getElementById('form');
    const fileEl = document.getElementById('image');
    const noteEl = document.getElementById('note');
    const btn = document.getElementById('go');

    const previewSec = document.getElementById('previewSec');
    const previewImg = document.getElementById('preview');
    const resultSec = document.getElementById('result');
    const totalEl = document.getElementById('total');
    const discEl = document.getElementById('disc');
    const itemsEl = document.getElementById('items');

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const f = fileEl.files?.[0];
      if (!f) return alert('이미지를 선택하세요.');

      btn.disabled = true; btn.textContent = '분석 중…';

      const localURL = URL.createObjectURL(f);
      previewImg.src = localURL;
      previewSec.classList.remove('hidden');

      const fd = new FormData();
      fd.append('image', f);
      if (noteEl.value.trim()) fd.append('note', noteEl.value.trim());

      try {
        const res = await fetch('/calorie/estimate', { method: 'POST', body: fd });
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        if (data.preview_url) previewImg.src = data.preview_url;
        render(data);
      } catch (e2) {
        alert('분석 실패: ' + e2);
      } finally {
        btn.disabled = false; btn.textContent = '분석하기';
      }
    });

    function render(d) {
      resultSec.classList.remove('hidden');
      totalEl.textContent = isFinite(d.total_calories_est) ? `총합: ${d.total_calories_est} kcal` : '총합 계산 불가';
      discEl.textContent = d.disclaimer || '';

      itemsEl.innerHTML = '';
      (d.items || []).forEach(it => {
        const div = document.createElement('div');
        div.className = 'border rounded-xl p-3 text-sm';
        div.innerHTML = `
          <div class="font-medium">${escapeHtml(it.name)} 
            ${it.mapped ? `<span class="ml-1 text-xs text-slate-500">(매핑: ${escapeHtml(it.mapped)})</span>` : ''}
          </div>
          <div class="text-slate-700">추정량: ${it.portion_g ?? '?'} g</div>
          <div class="text-slate-700">100g당: ${it.kcal_per_100g ?? '?'} kcal</div>
          <div class="font-semibold">추정 칼로리: ${it.calories_est ?? '?'} kcal</div>
        `;
        itemsEl.appendChild(div);
      });
    }

    function escapeHtml(s) {
      return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;');
    }
  </script>
</body>
</html>
```

`6)` 실행 & 테스트
```bash
uvicorn app.main:app --reload --port 8000
# 브라우저: http://localhost:8000/web/calorie.html
```

동작 방식 요약
1. 이미지 업로드 → 서버가 이미지를 base64 data-url로 바꿔 비전 LLM에 전달
2. LLM이 음식 이름 + 1인분 그램(추정) 을 구조화해서 돌려줌
3. 서버가 내부 영양 테이블(100g 당 kcal) 과 퍼지 매칭으로 항목별 칼로리 계산
4. 항목/총합 kcal 을 JSON으로 반환 → 프론트가 예쁘게 표시

정확도 & 한계
- 사진만으로 정확한 무게/음식 종별 판단은 어렵습니다 → 대략 추정치로 보세요.
- 더 정확히 하려면:
    - 음식명 힌트(예: 토핑 있는 마르게리타 피자 2조각)를 메모에 추가
    - 내부 영양 테이블을 풍부한 DB로 교체(예: FoodData Central/한국영양성분 DB)
    - 다중 이미지(정면/측면)·참조 객체(포크/카드)로 크기 추정 보정
    - 컵/조각/개수 단위도 허용해 LLM이 g로 환산하도록 프롬프트 강화