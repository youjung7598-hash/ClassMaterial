종류 예시:
- 사내 위키 RAG Q&A 봇: 위키/매뉴얼 기반으로 정확한 답만 주는 내부 도우미    
- 업무 자동화 에이전트(툴 콜링): 휴가 일정 등록해줘/이슈 만들기 같은 명령 실행
- 고객센터 챗봇(출처 표기): FAQ+매뉴얼 RAG, 답변에 근거(파일/페이지) 표시

---
##### 휴가 일정 등록/이슈 만들기 같은 업무 자동화 에이전트(툴 콜링)

사용자가 “홍길동 휴가 등록해줘”라고 말하면, LLM이 필요한 인자(이름/날짜/사유)를 추출하고 → 정의된 툴 함수(`create_vacation`)를 호출 → 툴이 데이터(JSON 파일)에 저장 → 결과를 받아 자연어 응답을 만들어 줍니다.

`0)` 새 프로젝트 만들기
```bash
mkdir automation-agent && cd automation-agent

# 가상환경(선택)
python -m venv .venv && source .venv/bin/activate   # Windows: .venv\Scripts\activate

# 필수 패키지
pip install langchain==0.1.10 langchain-openai python-dotenv fastapi uvicorn pydantic
```

프로젝트 구조
```
automation-agent/
├─ app/
│  ├─ main.py                 # FastAPI 엔트리포인트 (/agent/chat)
│  ├─ api/
│  │   └─ agent_routes.py     # /agent/* 엔드포인트
│  └─ agent/
│     ├─ agent.py             # 에이전트(툴 콜링) 실행 로직
│     └─ tools.py             # 휴가 등록, 이슈 생성툴 정의
├─ web/                       # 프론트 
│  └─ index.html
├─ data/
│  ├─ calendar.json           # (자동 생성) 휴가 일정 저장소(모의)
│  └─ issues.json             # (자동 생성) 이슈 저장소(모의)
├─ .env
└─ requirements.txt 
```

`.env`
```env
OPENAI_API_KEY=sk-...         # OpenAI API 키
OPENAI_MODEL=gpt-3.5-turbo-0125
```

`1)` 툴 정의: `app/agent/tools.py`
- 에이전트가 휴가 등록/이슈 생성을 직접 수행할 수 있도록 툴(함수) 정의
- 여기서는 외부 시스템 대신 로컬 JSON에 저장하는 모의 API로 구현
```python
# app/agent/tools.py
import os
import json
import uuid
import datetime
from typing import Optional, Literal
from langchain_core.tools import tool
from langchain_core.pydantic_v1 import BaseModel, Field

# ────────────────────────────────────────────────────────────────
# 경로/스토리지 유틸
# ────────────────────────────────────────────────────────────────
DATA_DIR = os.path.abspath(os.path.join(os.path.dirname(os.path.dirname(__file__)), "..", "data"))
CAL_PATH = os.path.join(DATA_DIR, "calendar.json")
ISS_PATH = os.path.join(DATA_DIR, "issues.json")
os.makedirs(DATA_DIR, exist_ok=True)

def _load(path: str):
    if not os.path.exists(path):
        with open(path, "w", encoding="utf-8") as f:
            json.dump([], f, ensure_ascii=False)
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def _save(path: str, data):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, ensure_ascii=False, indent=2)

# ────────────────────────────────────────────────────────────────
# 환경변수로 저장 스위치 제어
# DRY_RUN=true 이면 파일에 저장하지 않고 결과만 반환
# ────────────────────────────────────────────────────────────────
DRY_RUN = os.getenv("DRY_RUN", "false").lower() == "true"

# ────────────────────────────────────────────────────────────────
# 스키마: 휴가 등록
# ────────────────────────────────────────────────────────────────
class VacationInput(BaseModel):
    employee: str = Field(..., description="직원 이름")
    start_date: str = Field(..., description="YYYY-MM-DD")
    end_date: str   = Field(..., description="YYYY-MM-DD")
    reason: Optional[str] = Field(None, description="사유(선택)")

@tool("create_vacation", args_schema=VacationInput)
def create_vacation(employee: str, start_date: str, end_date: str, reason: Optional[str] = None) -> dict:
    """
    직원 휴가 일정을 생성한다.
    반환 예: {"ok": True, "vacation": {...}, "persisted": True|False}
    """
    # 날짜 검증
    try:
        sd = datetime.date.fromisoformat(start_date)
        ed = datetime.date.fromisoformat(end_date)
        assert ed >= sd
    except Exception:
        return {"ok": False, "error": "날짜 형식/순서가 잘못되었습니다(YYYY-MM-DD, 종료>=시작)."}

    item = {
        "id": uuid.uuid4().hex[:8],
        "employee": employee,
        "start_date": start_date,
        "end_date": end_date,
        "reason": (reason or "").strip(),
        "created_at": datetime.datetime.utcnow().isoformat() + "Z",
    }

    if DRY_RUN:
        # 저장하지 않고 결과만 반환
        return {"ok": True, "vacation": item, "persisted": False}

    data = _load(CAL_PATH)
    data.append(item)
    _save(CAL_PATH, data)
    return {"ok": True, "vacation": item, "persisted": True}

# ────────────────────────────────────────────────────────────────
# 스키마: 이슈 생성
# ────────────────────────────────────────────────────────────────
class IssueInput(BaseModel):
    title: str = Field(..., description="이슈 제목")
    description: str = Field(..., description="상세 설명")
    priority: Literal["low", "medium", "high"] = "medium"
    assignee: Optional[str] = Field(None, description="담당자(선택)")

@tool("create_issue", args_schema=IssueInput)
def create_issue(title: str, description: str, priority: str = "medium", assignee: Optional[str] = None) -> dict:
    """
    이슈 항목을 생성한다.
    반환 예: {"ok": True, "issue": {...}, "persisted": True|False}
    """
    item = {
        "id": uuid.uuid4().hex[:8],
        "title": title.strip(),
        "description": description.strip(),
        "priority": priority,
        "assignee": (assignee or "").strip(),
        "status": "open",
        "created_at": datetime.datetime.utcnow().isoformat() + "Z",
    }

    if DRY_RUN:
        # 저장하지 않고 결과만 반환
        return {"ok": True, "issue": item, "persisted": False}

    data = _load(ISS_PATH)
    data.append(item)
    _save(ISS_PATH, data)
    return {"ok": True, "issue": item, "persisted": True}

```

`2)` 에이전트 로직(툴 콜링): `app/agent/agent.py`
- 사용자 자연어 → LLM이 필요 툴/파라미터 자동 선택 → 툴 실행 → 결과를 반영한 최종 답변.
- LangChain 0.1.10 기준 가장 단순한 2-스텝 패턴으로 구현
```python
# app/agent/agent.py
import os
from typing import Dict, Any, List
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI
from langchain_core.messages import SystemMessage, HumanMessage, ToolMessage, AIMessage
from .tools import create_vacation, create_issue, DRY_RUN  # ⬅ DRY_RUN 가져와 안내에 활용

load_dotenv()
MODEL = os.getenv("OPENAI_MODEL", "gpt-3.5-turbo-0125")

# 1) LLM + Tools
_llm = ChatOpenAI(model=MODEL, temperature=0)
_llm_with_tools = _llm.bind_tools([create_vacation, create_issue])

_TOOL_REGISTRY = {
    "create_vacation": create_vacation,
    "create_issue": create_issue,
}

SYS_PROMPT = (
"You are an office automation assistant for a Korean company. "
"User commands may be informal. When tasks involve vacation or issue tracking, "
"use the provided tools with accurate arguments (YYYY-MM-DD for dates). "
"If required info is missing or date format is wrong, politely ask for the needed fields in Korean. "
"Always summarize the result succinctly in Korean, and show created IDs."
)

def _append_persist_note(reply: str, tool_results: List[Dict[str, Any]]) -> str:
    """DRY_RUN이거나 툴 결과가 persisted=False면 안내 문구를 덧붙임."""
    try:
        if DRY_RUN or any(r.get("result", {}).get("persisted") is False for r in tool_results):
            note = "\n\n(참고: 현재 DRY_RUN 모드로 실제 저장하지 않았습니다.)"
            return reply + note
    except Exception:
        pass
    return reply

def run_agent(user_text: str) -> Dict[str, Any]:
    """
    단일 턴:
    1) LLM이 툴 필요 여부/인자 생성
    2) 툴 실행 → 결과를 ToolMessage로 전달
    3) 최종 답변 생성
    """
    messages: List = [SystemMessage(content=SYS_PROMPT), HumanMessage(content=user_text)]

    # (1) 툴 선택/파라미터 작성
    ai_msg: AIMessage = _llm_with_tools.invoke(messages)
    tool_calls = getattr(ai_msg, "tool_calls", None)

    if not tool_calls:
        final = _llm.invoke(messages + [ai_msg])
        return {
            "reply": final.content,
            "tool_calls": [],
            "tool_results": [],
            "model": MODEL,
        }

    # (2) 툴 실행
    tool_results: List[Dict[str, Any]] = []
    tool_msgs: List[ToolMessage] = []

    for call in tool_calls:
        name = call.get("name")
        args = call.get("args", {})
        call_id = call.get("id")

        tool_fn = _TOOL_REGISTRY.get(name)
        if not tool_fn:
            result = {"ok": False, "error": f"unknown tool: {name}"}
        else:
            try:
                result = tool_fn.invoke(args)  # LangChain Tool은 invoke(args)로 실행
            except Exception as e:
                result = {"ok": False, "error": f"tool exception: {e}"}

        tool_results.append({"tool": name, "args": args, "result": result})
        tool_msgs.append(ToolMessage(tool_call_id=call_id, content=str(result)))

    # (오류 처리) 툴 중 하나라도 실패하면, 부족한 정보/형식 안내 질문을 LLM에 요청
    if any(not (r["result"].get("ok") is True) for r in tool_results):
        ask_msg = HumanMessage(
            content=(
                "위 툴 실행이 실패했습니다. 부족한 정보나 잘못된 형식을 한국어로 친절하게 알려주고, "
                "사용자가 바로 수정해 말할 수 있도록 예시를 들어주세요."
            )
        )
        final_err = _llm.invoke(messages + [ai_msg] + tool_msgs + [ask_msg])
        return {
            "reply": final_err.content,
            "tool_calls": tool_calls,
            "tool_results": tool_results,
            "model": MODEL,
        }

    # (3) 성공 케이스: 툴 결과 반영하여 최종 자연어 답변
    final = _llm.invoke(messages + [ai_msg] + tool_msgs)
    reply = _append_persist_note(final.content, tool_results)

    return {
        "reply": reply,
        "tool_calls": tool_calls,
        "tool_results": tool_results,
        "model": MODEL,
    }
```

`3)` FastAPI 엔드포인트: `app/main.py`
프론트엔드/포스트맨/커맨드라인에서 쉽게 호출해보는 용도.
```python
# app/main.py
import os
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.responses import RedirectResponse
from dotenv import load_dotenv
from app.api.agent_routes import router as agent_router

load_dotenv()

app = FastAPI(title="Automation Agent (Tool-Calling)", version="1.0.0")

# CORS (같은 서버에서 서빙하면 크게 필요 없지만 남겨둬도 OK)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], allow_credentials=True,
    allow_methods=["*"], allow_headers=["*"],
)

# API 라우터
app.include_router(agent_router)

# 정적 프론트 서빙: http://localhost:8000/web/
app.mount("/web", StaticFiles(directory="web", html=True), name="web")

@app.get("/")
def root():
    # 기본 경로에서 바로 프론트로 리디렉트
    return RedirectResponse(url="/web/")
```

`4)` 라우터 파일 만들기 — `app/api/agent_routes.py`
```python
# app/api/agent_routes.py
from fastapi import APIRouter
from pydantic import BaseModel
from app.agent.agent import run_agent

router = APIRouter(prefix="/agent", tags=["agent"])

class ChatIn(BaseModel):
    message: str

@router.post("/chat")
def agent_chat(payload: ChatIn):
    return run_agent(payload.message)

@router.get("/ping")
def ping():
    return {"ok": True}
```

프론트 페이지
Tailwind CDN 사용. 입력창 + 응답 패널 + 샘플 명령 버튼 포함
`web/index.html`
```html
<script>
  const form = document.getElementById('chat-form');
  const input = document.getElementById('message');
  const sendBtn = document.getElementById('send');
  const chat = document.getElementById('chat');
  const sampleBtns = document.querySelectorAll('[data-sample]');

  // 같은 서버에서 서빙하므로 상대 경로 사용 (/agent/chat)
  const API_URL = '/agent/chat';

  sampleBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      input.value = btn.dataset.sample;
      input.focus();
    });
  });

  form.addEventListener('submit', async (e) => {
    e.preventDefault();
    const msg = input.value.trim();
    if (!msg) return;

    // 사용자 버블 추가
    addBubble('user', escapeHtml(msg));

    input.value = '';
    input.disabled = true;
    sendBtn.disabled = true;

    // 로딩 버블
    const loadingId = addBubble('bot', '처리 중… ⏳');

    try {
      const res = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: msg })
      });

      if (!res.ok) {
        const text = await res.text();
        updateBotBubble(loadingId, buildErrorMarkup(`오류(${res.status}) : ${escapeHtml(text)}`));
        return;
      }

      const data = await res.json();
      const reply = data?.reply ?? '(빈 응답)';
      updateBotBubble(loadingId, buildBotMarkup(reply, data));
    } catch (err) {
      updateBotBubble(loadingId, buildErrorMarkup(`요청 실패: ${escapeHtml(err?.message || err)}`));
    } finally {
      input.disabled = false;
      sendBtn.disabled = false;
      input.focus();
      scrollToBottom();
    }
  });

  // ──────────────────────────────
  // 렌더 헬퍼
  // ──────────────────────────────
  function addBubble(role, htmlOrText) {
    const id = 'm' + Math.random().toString(36).slice(2, 9);
    const wrap = document.createElement('div');
    wrap.id = id;
    wrap.className = role === 'user' ? 'flex justify-end' : 'flex justify-start';

    const bubble = document.createElement('div');
    bubble.className = (role === 'user'
      ? 'bg-blue-600 text-white'
      : 'bg-white text-slate-900 border') + ' max-w-[85%] rounded-2xl px-4 py-3 shadow';
    bubble.innerHTML = typeof htmlOrText === 'string' ? htmlOrText : '';
    wrap.appendChild(bubble);
    chat.appendChild(wrap);
    scrollToBottom();
    return id;
  }

  function updateBotBubble(id, markup) {
    const wrap = document.getElementById(id);
    if (!wrap) return;
    const bubble = wrap.firstChild;
    bubble.innerHTML = markup;
    // ID 하이라이트 (단순 패턴)
    bubble.innerHTML = bubble.innerHTML.replace(/(ID=)([a-z0-9]{6,12})/gi, '$1<strong>$2</strong>');
  }

  function buildBotMarkup(replyText, data) {
    const safeReply = escapeHtml(replyText).replace(/\n/g, '<br/>');

    // persisted 배지: tool_results[].result.persisted가 false면 DRY_RUN, true면 저장됨
    const persisted = inferPersisted(data);
    let badge = '';
    if (persisted === false) {
      badge = `<span class="ml-2 px-2 py-0.5 rounded-full text-xs bg-amber-200 text-amber-900 align-middle">DRY_RUN (미저장)</span>`;
    } else if (persisted === true) {
      badge = `<span class="ml-2 px-2 py-0.5 rounded-full text-xs bg-emerald-200 text-emerald-900 align-middle">저장됨</span>`;
    }

    const tools = formatToolSectionHTML(data);
    return `${safeReply}${badge}${tools}`;
  }

  function buildErrorMarkup(msg) {
    return `<div class="text-red-700">${msg}</div>`;
  }

  function formatToolSectionHTML(data) {
    try {
      const calls = data?.tool_calls || [];
      const results = data?.tool_results || [];
      if (!calls.length && !results.length) return '';
      const pretty = escapeHtml(JSON.stringify({ tool_calls: calls, tool_results: results }, null, 2));
      return `
        <div class="mt-3 border-t pt-2">
          <details>
            <summary class="cursor-pointer text-sm text-slate-600">도구 실행 로그</summary>
            <pre class="bg-slate-100 rounded-xl p-3 text-xs overflow-auto max-h-80 mt-2">${pretty}</pre>
          </details>
        </div>
      `;
    } catch {
      return '';
    }
  }

  function inferPersisted(data) {
    try {
      const results = data?.tool_results || [];
      for (const r of results) {
        const p = r?.result?.persisted;
        if (p === false) return false;
        if (p === true) return true;
      }
    } catch {}
    return null; // 알 수 없음
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;');
  }

  function scrollToBottom() {
    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
  }
</script>
```

`6)` 실행 & 테스트
```bash
uvicorn app.main:app --reload --port 8000
```

결과확인
휴가 등록 완료! ID=xxxx… 같은 문장과 함께 `[도구 실행 로그]` 텍스트로 보임

필요시 달력 패널을 붙여서 브라우저에서 휴가 일정표를 추가할수 있습니다.