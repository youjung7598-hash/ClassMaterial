#### 1) 핵심 관점별로 무엇을 보나

##### a) 가용성 (서비스가 살아있나?)

- 대표 지표
    - `up` (Gauge, Prometheus가 생성)
        - 1 = 대상 타깃이 수집됨(UP), 0 = 수집 실패(DOWN)
            
- 주요 라벨: `job`(fastapi/django/node_exporter), `instance`(호스트:포트)
    
- 해석 포인트
    - 특정 `job`이 0이면 앱이 죽었거나 바인딩/네트워크/타깃 설정 문제.
    - 짧은 순간 0 → 스크레이프 실패(일시적 네트워크), 연속 0 → 장애로 판단.
        
---
##### b) 트래픽 (얼마나 들어오나? RPS/요청량)

- 대표 지표
    - FastAPI: `http_requests_total` (Counter)
    - Django: `django_http_responses_total_by_status_view_method_total` (Counter)
        
- 주요 라벨
    - 공통: `method`, `status`
    - FastAPI 추가: `handler`(엔드포인트/경로 비슷한 의미)
    - Django 추가: `view`(뷰 이름)
        
- 해석 포인트
    - RPS(초당 요청수)는 Counter에 `rate()`를 적용해 본다.
        - 예: `rate(http_requests_total[5m])`
    - `method/status/handler(view)`로 분해해 **어떤 경로·상태코드**가 많은지 확인.
    - `/metrics`는 모니터링용 트래픽이라 제외하는 편이 깨끗하다.
        
---
##### c) 성능 (얼마나 빨리 응답하나? 지연시간)

- 대표 지표(히스토그램 권장)
    - FastAPI: `http_request_duration_seconds_bucket` (Histogram)
    - Django: `django_http_requests_latency_including_middlewares_seconds_bucket` 또는  
        `django_http_requests_latency_seconds_by_view_method_bucket` (Histogram)
        
- 주요 라벨
    - FastAPI: `handler`, `method`, `le`(버킷 경계)
    - Django: `view`, `method`, `le`
        
- 해석 포인트
    - p95/p99는 히스토그램 버킷으로 계산(사용자 체감 성능 지표).
    - 특정 `handler/view`만 느려지면 해당 API 병목 가능성.
    - 평균만 보지 말고 백분위를 보아야 꼬리 지연을 잡을 수 있다.
        
---
##### d) 오류 (얼마나 실패하나? 에러율)

- 대표 지표
    - FastAPI: `http_requests_total{status=~"5.."}` (Counter)
    - Django: `django_http_responses_total_by_status_view_method_total{status=~"5.."}` (**Counter**)
        
- 주요 라벨: `status`, `method`, `handler/view`
    
- 해석 포인트
    - 에러율 = 5xx 요청 / 전체 요청 (보통 1% 미만 목표).
    - 특정 `handler/view`에서만 5xx ↑ → 코드/의존 서비스 점검.
    - 4xx가 급증하면 클라이언트 사용성/계약(API 스펙) 문제 가능.
        
---
##### e) 리소스 (서버 자원은 충분한가?)

- 대표 지표 (node_exporter)
    - CPU: `node_cpu_seconds_total` → 보통 idle로 계산하여 CPU% 파생(Gauge)
    - 메모리: `node_memory_MemAvailable_bytes` (**Gauge**)
    - 디스크: `node_filesystem_avail_bytes` (**Gauge**)
    - 네트워크: `node_network_{receive,transmit}_bytes_total` (**Counter**)
        
- 해석 포인트
    - CPU 스파이크가 성능/지연 악화와 동시에 일어나는지 상관관계 확인.
    - 메모리 여유가 낮으면 GC/스왑/OOM 위험 → 지연/장애로 이어질 수 있음.
    - 디스크/네트워크는 장기 추세로 용량 계획(capacity planning)에 중요.
        
---
### 모니터링 용어

`1)` 데이터 모델·수집 단위

- Metric(메트릭)  
    “무엇을 측정했는가”의 이름. 예) `http_requests_total`(요청 수), `process_resident_memory_bytes`(메모리).  
     └ 네이밍 팁: 누적값은 `_total`, 시간은 `_seconds`, 크기는 `_bytes`처럼 단위를 이름에 붙인다.
    
- Label(라벨)  
    메트릭에 붙는 태그(차원). 예) `method`, `status`, `handler`(경로/엔드포인트), `job`, `instance`.  
     └ “어떤 API/상태코드/서버의 값인가?”를 구분하는 열쇠.  
     └ 주의: `user_id`, `request_id`, timestamp 같은 무한히 늘어나는 값은 라벨로 넣지 말기(카디널리티 폭발).
    
- Time series(시계열)  
    시간 + 메트릭 + 라벨 조합으로 저장되는 값의 흐름. Grafana에서 시간축 그래프로 본다.
    
- Exporter  
    OS·미들웨어 지표를 `/metrics`로 내주는 모듈. 예) **node_exporter**(CPU/메모리/디스크/네트워크).
    
- Target / Instance / Job
    - Target: Prometheus가 긁는 엔드포인트(예: `host:8000/metrics`).
    - Instance: Target의 식별자(보통 `host:port`).
    - Job: 관련 Target의 그룹 이름(예: `fastapi`, `django`).
        
- Scrape interval / timeout  
    Prometheus가 `/metrics`를 얼마나 자주/얼마나 오래 기다리며 긁을지의 설정(예: 15초 / 10초).
    
- PromQL  
    Prometheus를 조회하는 쿼리 언어. (개념만 알아도 시작 가능)  
    Counter의 속도는 `rate()`, 라벨로 묶을 때 `sum by(...)`.
    
---
`2)` 메트릭 타입(꼭 구분!)

- Counter(카운터)  
    0에서 시작해 오르기만 하는 누적값(요청 수, 에러 수).  
     └ 초당 속도(RPS 등)는 `rate(counter[5m])`로 본다. 재시작으로 0이 되어도 rate가 자동 보정.
    
- Gauge(게이지)  
    위아래로 증감하는 현재값(CPU%, 사용 메모리, 동시요청 수).  
     └ 있는 그대로 보거나 `avg_over_time(gauge[5m])`처럼 창을 두고 평균.
    
- Histogram(히스토그램)  
    분포를 버킷(le 라벨)으로 저장. p95/p99 같은 백분위 계산에 최적.  
     └ 예: 요청 지연시간 분포를 버킷에 누적 → p95 계산.
    
- Summary(써머리)  
    로컬에서 백분위를 추정해 주지만 여러 인스턴스를 합치기 어렵다.  
     └ 초반엔 Histogram 권장.
    
---
`3)` 서비스 관점 핵심 지표(무엇을 보나)

- 가용성(살아있나?)
    - `up` (**Gauge**, 1=수집 성공, 0=실패).
    - 연속 0이면 장애·네트워크·타깃 설정 문제를 의심.
        
- 트래픽(얼마나 들어오나? RPS)
    - FastAPI: `http_requests_total`(Counter)
    - Django: `django_http_responses_total_by_status_view_method_total`(Counter)
    - 라벨 `method/status/handler(view)`로 어떤 경로/상태코드가 많은지 본다.
    - RPS는 Counter + `rate()`. `/metrics` 트래픽은 분석에서 제외 권장.
        
- 성능(얼마나 빨리 응답하나?)
    - 지연시간 Histogram으로 p95/p99 확인.
    - 평균만 보지 말고 백분위를 봐야 “꼬리 지연”을 잡는다.
    - 느린 `handler/view`가 있으면 해당 API 병목 가능.
        
- 오류(얼마나 실패하나?)
    - 5xx 비율 = 5xx 요청 / 전체 요청. 보통 1% 미만을 목표(SLO 예시).
    - 특정 경로에서만 5xx↑ → 코드·의존 서비스 점검.
        
- 리소스(버틸 여력 있나?) — node_exporter
    - CPU: idle을 기준으로 사용률 계산.
    - 메모리: `MemAvailable`로 여유 확인(낮으면 GC/스왑/OOM 위험).
    - 디스크/네트워크: 용량·I/O 추세로 병목·용량계획 점검.
        
---
`4)` SLI/SLO·알림 기본
- SLI(Service Level Indicator): 실제 측정 지표(에러율, p95 등).
- SLO(Service Level Objective): SLI의 목표값(예: 에러율 < 1%, p95 < 800ms).
- Alert: SLO를 벗어나거나, 빠르게 악화될 때(5분 평균 5xx↑, p95↑ 등) 알림.
    
---
`5)` 카디널리티(Cardinality) – 꼭 주의
- 뜻: “라벨 조합의 가짓수”. 많아질수록 저장·쿼리 비용이 급증.
- 하지 말 것: `request_id`, `user_id`, timestamp를 라벨로 넣기.
- 권장: `method/status/handler(view)/service/version` 같은 고정 폭 라벨만 사용.
    
---
한 줄 결론
- 메트릭 이름은 “무엇을 측정”, 라벨은 “어디/어떤 조건”, 시계열은 “시간의 흐름”.
- Counter vs Gauge vs Histogram만 제대로 구분해도 절반은 끝.
- 운영에서 늘 보는 건 up / RPS / p95 / 5xx / CPU·메모리 — 이 다섯 축이다.
	
---
라벨 사용 가이드(실수 방지)
	각 메트릭 값에 함께 붙어 있는 `키=값` 태그를 라벨이라고 합니다.
	라벨은 메트릭에 붙는 태그로, 어디서/무엇이 발생했는지 구분합니다.

- 기본 라벨만 먼저: `method`, `status`, `handler(view)`, `job`, `instance`.
- 가변 값(요청 ID, 사용자 ID, timestamp 등)을 라벨로 넣지 말기 → 카디널리티 폭발.
- `/metrics` 자체 트래픽은 라벨/필터로 빼서 분석 노이즈 줄이기.
- 서비스/버전별 비교가 필요하면 `service`, `version` 정도로 고정 폭의 라벨만 추가.

라벨예시
```
http_requests_total{handler="/metrics", method="GET", status="2xx"} 114
```
이 한 줄의 뜻
- 메트릭 이름: `http_requests_total`  
    → “HTTP 요청 수(누적 Counter)”를 뜻해요.
    
- 라벨(태그): `{handler="/metrics", method="GET", status="2xx"}`  
    → 이 시계열이 어떤 요청들을 세는지 조건을 지정합니다.
    - `handler="/metrics"` : `/metrics` 엔드포인트로 들어온 요청
    - `method="GET"` : GET 방식
    - `status="2xx"` : 2xx(성공) 범주의 응답
        
- 값: `114`  
    → 해당 조건을 만족한 요청의 누적 개수(프로세스 시작 이후)입니다.  
    즉, “시작 후 지금까지 `/metrics`로 들어온 GET 성공요청이 114번 있었다”는 의미예요.  
    참고: Prometheus가 15초마다 `/metrics`를 긁으니 이 값이 계속 올라갑니다.
    
> 요약: “/metrics에 GET 성공(2xx) 요청이 총 114번 있었다.”

Prometheus UI( [http://localhost:9090/graph](http://localhost:9090/graph) )
쿼리창에 그대로 입력:
```
http_requests_total{handler="/metrics", method="GET", status="2xx"}
```
![[Pasted image 20250819163757.png]]
![[Pasted image 20250819163825.png]]

---
### 최소 모니터링 목표

`1)` 가용성 (서비스 살아있나?)
- 목표: `up == 1` 유지
- 왜 중요?: 0이면 Prometheus가 타깃(`/metrics`)에 **접속 자체가 실패**한 상태.
- 위험 신호: `up`이 0으로 내려가거나 깜빡깜빡(간헐적 0)함.
- 바로 할 일
    - 앱이 떠있는지/포트가 맞는지 확인(0.0.0.0 바인딩, 방화벽)
    - Prometheus 타깃 주소/포트 오타 체크
    - Django면 `ALLOWED_HOSTS`에 수집 주체(host.docker.internal 등) 포함
        
---
`2)` 트래픽 (얼마나 들어오나? RPS)
- 목표: “평소 범위” 유지(팀이 정한 기준선).
- 왜 중요?: 급증/급감은 **이벤트·배포·에러 재시도 루프**의 신호일 수 있음.
- 위험 신호: RPS 급등(스케일 아웃 필요), 급감(서비스 죽음/라우팅 문제).
- 바로 할 일
    - 최근 배포·프로모션·크롤러 유입 여부 확인
    - 에러율(5xx)과 함께 보기 → 실패 재시도로 인한 **비정상 급증**인지 체크
        
---
`3)` 성능 (응답 속도: p95)
- 목표(시작점): p95 < 800ms (경로별로 관리)
- 왜 중요?: 상위 95%의 요청이 800ms 이내 → 대부분의 사용자가 빠르다고 느낌.
- 위험 신호: p95가 평소보다 계속 높음(일시적 스파이크는 OK, 지속적 상승은 위험).
- 바로 할 일
    - 경로(핸들러/뷰)별로 쪼개 보기 → 어느 API가 느린지 찾기
    - DB 쿼리/외부 API/캐시 적중률 점검(인덱스, N+1, 타임아웃)
        
---
`4)` 오류 (실패 비율)
- 목표(시작점): 5xx < 1%
- 왜 중요?: 사용자 체감 품질/가용성과 직결.
- 위험 신호: 전체 혹은 특정 경로에서 5xx가 지속적으로 상승.
- 바로 할 일
    - 상태코드 라벨로 5xx만 필터링, 경로/서비스(job) 별로 분해
    - 최근 배포/설정 변경 확인, 에러 로그/스택트레이스 확인
    - 필요 시 롤백·피처 플래그로 차단
        
---
 `5)` 리소스 (서버 자원 여유)
- CPU
    - 목표: 평균 < **70%**, 짧은 스파이크 OK / 지속 고사용률은 위험
    - 조치: 스케일 아웃, 비싼 연산·쿼리 최적화
- 메모리
    - 목표: 여유 20%+ 유지, 스왑 사용 0에 가까움
    - 조치: 메모리 누수 점검, 캐시 정책/워커 수 조정
- 디스크
    - 목표: 사용률 < **80%**, 파일시스템 에러/재시도 없음
    - 조치: 로그 롤테이션, 디스크 증설, 임시파일 정리
- 네트워크
    - 목표: 드롭/에러 패킷 거의 0, 레이턴시 안정
    - 조치: 대역폭·방화벽·로드밸런서 설정 점검
        
---
애플리케이션
- 가용성: 타깃이 살아있는지(UP)
- 트래픽: 메서드/경로/상태별 요청량
- 성능: **p95 지연시간**(Histogram 기반)
- 오류: 5xx 비율(전체 대비)
    
인프라(node_exporter)
- CPU 사용률(과도한 스파이크 여부)
- 메모리 여유(OOM 위험)
- 디스크 여유/사용률
- 네트워크 I/O(수신/송신 바이트)
    
 AI/LLM
- 요청 수/실패 수, 지연시간 p95, 토큰/비용, 캐시 히트율
---
> 한 줄 요약: 살아있나(UP) → 들어오나(RPS) → 빠른가(p95) → 안터지나(5xx) → 버틸 자원 있나(CPU/메모리/디스크/네트워크)  
> 이 다섯 가지만 꾸준히 보면 “기본 모니터링”은 충분합니다.
---

![[Pasted image 20250813131619.png]]

![[Pasted image 20250813131634.png]]

![[Pasted image 20250813131742.png]]


---
